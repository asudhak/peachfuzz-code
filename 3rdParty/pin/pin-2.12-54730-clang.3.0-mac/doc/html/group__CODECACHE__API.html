<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Pin: Code Cache API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Code Cache API</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VOID(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga98bf4df2161b9cecbe77ffedfd0fd2f8">LEVEL_PINCLIENT::CODECACHE_NOARG_CALLBACK</a> )()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VOID(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga37b85643fe15f437bd36330001b4ca5b">LEVEL_PINCLIENT::CODECACHE_CACHEBLOCK_CALLBACK</a> )(USIZE new_block_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VOID(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gabe86a24a3af58f9fdf9f748c17ea0a25">LEVEL_PINCLIENT::CODECACHE_FULL_CALLBACK</a> )(USIZE trace_size, USIZE stub_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VOID(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga197457580426e1cef2a5251615a45bb6">LEVEL_PINCLIENT::CODECACHE_ENTEREXIT_CALLBACK</a> )(ADDRINT cache_pc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VOID(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga3e65e760fb4fc84568a736ef3c0a062d">LEVEL_PINCLIENT::CODECACHE_LINKED_CALLBACK</a> )(ADDRINT branch_pc, ADDRINT target_pc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VOID(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gac02c7c2aa22326a08955162d2dc0448a">LEVEL_PINCLIENT::CODECACHE_UNLINKED_CALLBACK</a> )(ADDRINT branch_pc, ADDRINT stub_pc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VOID(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga506353952adfe0fe732bed4c2c45ea5b">LEVEL_PINCLIENT::CODECACHE_TRACEINVALIDATED_CALLBACK</a> )(ADDRINT orig_pc, ADDRINT cache_pc, BOOL success)</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga818608c3e3d4efee4d3499c6e1df8d10">LEVEL_PINCLIENT::CODECACHE_AddCacheInitFunction</a> (CODECACHE_NOARG_CALLBACK fun, VOID *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gaaed7d3509a81feb381792758af89ac18">LEVEL_PINCLIENT::CODECACHE_AddCacheBlockFunction</a> (CODECACHE_CACHEBLOCK_CALLBACK fun, VOID *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga16a21596da23ddd7e8463027f66a0134">LEVEL_PINCLIENT::CODECACHE_AddFullCacheFunction</a> (CODECACHE_FULL_CALLBACK fun, VOID *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gadef7979c1ffe2526b256e1eecd116a0f">LEVEL_PINCLIENT::CODECACHE_AddCacheFlushedFunction</a> (CODECACHE_NOARG_CALLBACK fun, VOID *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gabed1ea94c5934d1cffbcfcfe09a1bcbe">LEVEL_PINCLIENT::CODECACHE_AddCodeCacheEnteredFunction</a> (CODECACHE_ENTEREXIT_CALLBACK fun, VOID *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gab125523cb430986a71858e0768753565">LEVEL_PINCLIENT::CODECACHE_AddCodeCacheExitedFunction</a> (CODECACHE_ENTEREXIT_CALLBACK fun, VOID *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gac5310fb42f264cc4c2b874d7b6e3f1de">LEVEL_PINCLIENT::CODECACHE_AddTraceLinkedFunction</a> (CODECACHE_LINKED_CALLBACK fun, VOID *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gab4b491a7925e0e1f172b19138c51a395">LEVEL_PINCLIENT::CODECACHE_AddTraceUnlinkedFunction</a> (CODECACHE_UNLINKED_CALLBACK fun, VOID *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga6e213a8bb18a2a0704eab23472a07842">LEVEL_PINCLIENT::CODECACHE_AddTraceInvalidatedFunction</a> (CODECACHE_TRACEINVALIDATED_CALLBACK fun, VOID *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gaf39fec242a10c873fb397f5e3d523ed1">LEVEL_PINCLIENT::CODECACHE_InvalidateTraceAtProgramAddress</a> (ADDRINT app_pc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga54123ca5c5d213041e46c3c47d1030a1">LEVEL_PINCLIENT::CODECACHE_CodeMemReserved</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga285de63369aba24328ddaecd8511e1df">LEVEL_PINCLIENT::CODECACHE_DirectoryMemUsed</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga03d298cac03ab619c7d9575ca1bc4408">LEVEL_PINCLIENT::CODECACHE_CodeMemUsed</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gae8971f6762d05f83a017263d024db3c5">LEVEL_PINCLIENT::CODECACHE_ExitStubBytes</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga7c8f5165231ddc04eeb2694c58015855">LEVEL_PINCLIENT::CODECACHE_LinkBytes</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gaa12252f735d860ac0288435c0db72a9b">LEVEL_PINCLIENT::CODECACHE_CacheSizeLimit</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gaaf55a4da7c062b4fedb4544d5ef95981">LEVEL_PINCLIENT::CODECACHE_BlockSize</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gabb8af5ba8a4b6f1346ed468811339e4c">LEVEL_PINCLIENT::CODECACHE_NumTracesInCache</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga946dc189f085d5f742be7b0a66db9d2d">LEVEL_PINCLIENT::CODECACHE_NumExitStubsInCache</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gae89e0062f0129394fafae468a6bf8350">LEVEL_PINCLIENT::CODECACHE_CreateNewCacheBlock</a> (USIZE block_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga4a69b3c0ecdbc972c3d79f98491f21d8">LEVEL_PINCLIENT::CODECACHE_ChangeCacheLimit</a> (USIZE cache_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga0ef157780b28486a4757270c00b66108">LEVEL_PINCLIENT::CODECACHE_ChangeBlockSize</a> (USIZE block_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gaa057bcb372b7aae955e163e08e38bf82">LEVEL_PINCLIENT::CODECACHE_ChangeMaxInsPerTrace</a> (UINT32 max_ins)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gae2e1311e142234e705d6f6367b435428">LEVEL_PINCLIENT::CODECACHE_ChangeMaxBblsPerTrace</a> (UINT32 max_basic_blocks)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga3773a88d72d3ceec4c35757e4beb2160">LEVEL_PINCLIENT::CODECACHE_FlushCache</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gab979188050e346d3c01a7de307e9cbe7">LEVEL_PINCLIENT::CODECACHE_InvalidateRange</a> (ADDRINT start, ADDRINT end)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ADDRINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga2442ec5df29c4264fc2b0189ce1e0c2a">LEVEL_PINCLIENT::INS_CodeCacheAddress</a> (INS ins)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ADDRINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga68e95df926aa9a43fa77283c7c1d409a">LEVEL_PINCLIENT::BBL_CodeCacheAddress</a> (BBL bbl)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ADDRINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga3649ba022457e9fec1b4b894f161933c">LEVEL_PINCLIENT::TRACE_CodeCacheAddress</a> (TRACE trace)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">USIZE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga6da59177d8a31602356372817ac1c8e2">LEVEL_PINCLIENT::INS_CodeCacheSize</a> (INS ins)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">USIZE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga137cff9c8f26211b79bd129f864bb0a1">LEVEL_PINCLIENT::BBL_CodeCacheSize</a> (BBL bbl)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">USIZE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga16a68b7cb85cdb2a707bf1adb9f4714c">LEVEL_PINCLIENT::TRACE_CodeCacheSize</a> (TRACE trace)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ADDRINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gabe51bc22d2bd5ced0bc5526cde76f8d9">LEVEL_PINCLIENT::CODECACHE_OriginalAddress</a> (ADDRINT cache_pc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">USIZE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga85ee054bf89f654d960556d145c600f6">LEVEL_PINCLIENT::PIN_MemoryAllocatedForPin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gad57a8a7b92874d148f837c4b13b0a641">LEVEL_PINCLIENT::CODECACHE_AddTraceInsertedFunction</a> (TRACE_INSTRUMENT_CALLBACK fun, VOID *val)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This API allows the user to inspect Pin's code cache and/or alter the code cache replacement policy. For example, to alter the replacement policy, a user can register a routine that is called anytime the cache is full.<br/>
 APIs from this group are available in any thread, including any internal thread spawned by the tool. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga37b85643fe15f437bd36330001b4ca5b"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_CACHEBLOCK_CALLBACK" ref="ga37b85643fe15f437bd36330001b4ca5b" args=")(USIZE new_block_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(* LEVEL_PINCLIENT::CODECACHE_CACHEBLOCK_CALLBACK)(USIZE new_block_size)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call back function when Pin's code cache adds a new cache block </p>

</div>
</div>
<a class="anchor" id="ga197457580426e1cef2a5251615a45bb6"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_ENTEREXIT_CALLBACK" ref="ga197457580426e1cef2a5251615a45bb6" args=")(ADDRINT cache_pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(* LEVEL_PINCLIENT::CODECACHE_ENTEREXIT_CALLBACK)(ADDRINT cache_pc)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call back function when control enters or exits code cache </p>

</div>
</div>
<a class="anchor" id="gabe86a24a3af58f9fdf9f748c17ea0a25"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_FULL_CALLBACK" ref="gabe86a24a3af58f9fdf9f748c17ea0a25" args=")(USIZE trace_size, USIZE stub_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(* LEVEL_PINCLIENT::CODECACHE_FULL_CALLBACK)(USIZE trace_size, USIZE stub_size)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call back function when Pin's code cache is full </p>

</div>
</div>
<a class="anchor" id="ga3e65e760fb4fc84568a736ef3c0a062d"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_LINKED_CALLBACK" ref="ga3e65e760fb4fc84568a736ef3c0a062d" args=")(ADDRINT branch_pc, ADDRINT target_pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(* LEVEL_PINCLIENT::CODECACHE_LINKED_CALLBACK)(ADDRINT branch_pc, ADDRINT target_pc)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call back function when a trace is linked </p>

</div>
</div>
<a class="anchor" id="ga98bf4df2161b9cecbe77ffedfd0fd2f8"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_NOARG_CALLBACK" ref="ga98bf4df2161b9cecbe77ffedfd0fd2f8" args=")()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(* LEVEL_PINCLIENT::CODECACHE_NOARG_CALLBACK)()</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call back function that passes no arguments </p>

</div>
</div>
<a class="anchor" id="ga506353952adfe0fe732bed4c2c45ea5b"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_TRACEINVALIDATED_CALLBACK" ref="ga506353952adfe0fe732bed4c2c45ea5b" args=")(ADDRINT orig_pc, ADDRINT cache_pc, BOOL success)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(* LEVEL_PINCLIENT::CODECACHE_TRACEINVALIDATED_CALLBACK)(ADDRINT orig_pc, ADDRINT cache_pc, BOOL success)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call back function when Pin removes a region from the cache </p>

</div>
</div>
<a class="anchor" id="gac02c7c2aa22326a08955162d2dc0448a"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_UNLINKED_CALLBACK" ref="gac02c7c2aa22326a08955162d2dc0448a" args=")(ADDRINT branch_pc, ADDRINT stub_pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(* LEVEL_PINCLIENT::CODECACHE_UNLINKED_CALLBACK)(ADDRINT branch_pc, ADDRINT stub_pc)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call back function when a trace is unlinked </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga68e95df926aa9a43fa77283c7c1d409a"></a><!-- doxytag: member="LEVEL_PINCLIENT::BBL_CodeCacheAddress" ref="ga68e95df926aa9a43fa77283c7c1d409a" args="(BBL bbl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ADDRINT LEVEL_PINCLIENT::BBL_CodeCacheAddress </td>
          <td>(</td>
          <td class="paramtype">BBL&#160;</td>
          <td class="paramname"> <em>bbl</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine determines the starting code cache address of a basic block (Note: Only valid after code cache space has been allocated for this trace - normally after the instrumentation phase.) </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Code Cache Address</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga137cff9c8f26211b79bd129f864bb0a1"></a><!-- doxytag: member="LEVEL_PINCLIENT::BBL_CodeCacheSize" ref="ga137cff9c8f26211b79bd129f864bb0a1" args="(BBL bbl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USIZE LEVEL_PINCLIENT::BBL_CodeCacheSize </td>
          <td>(</td>
          <td class="paramtype">BBL&#160;</td>
          <td class="paramname"> <em>bbl</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine determines the code cache footprint of a basic block (Note: Only valid after code cache space has been allocated for this trace - normally after the instrumentation phase.) </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Size of the basic block in the code cache</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gaaed7d3509a81feb381792758af89ac18"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_AddCacheBlockFunction" ref="gaaed7d3509a81feb381792758af89ac18" args="(CODECACHE_CACHEBLOCK_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::CODECACHE_AddCacheBlockFunction </td>
          <td>(</td>
          <td class="paramtype">CODECACHE_CACHEBLOCK_CALLBACK&#160;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds a function that gets called whenever a new cache block is formed.</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gadef7979c1ffe2526b256e1eecd116a0f"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_AddCacheFlushedFunction" ref="gadef7979c1ffe2526b256e1eecd116a0f" args="(CODECACHE_NOARG_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::CODECACHE_AddCacheFlushedFunction </td>
          <td>(</td>
          <td class="paramtype">CODECACHE_NOARG_CALLBACK&#160;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds a function that gets called whenever the cache is physically flushed. Note that this event may occur later than the point at which the flush was first requested, either because we were in an analysis routine so it wasn't safe to flush, or because we are running a multithreaded application and we needed to wait for all threads to move out of the traces they were executing before we could flush. (But rest assured that no traces were entered between the time that the flush was requested and when this callback occurs.)</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga818608c3e3d4efee4d3499c6e1df8d10"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_AddCacheInitFunction" ref="ga818608c3e3d4efee4d3499c6e1df8d10" args="(CODECACHE_NOARG_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::CODECACHE_AddCacheInitFunction </td>
          <td>(</td>
          <td class="paramtype">CODECACHE_NOARG_CALLBACK&#160;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds a function that gets called once, when the code cache is first formed.</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gabed1ea94c5934d1cffbcfcfe09a1bcbe"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_AddCodeCacheEnteredFunction" ref="gabed1ea94c5934d1cffbcfcfe09a1bcbe" args="(CODECACHE_ENTEREXIT_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::CODECACHE_AddCodeCacheEnteredFunction </td>
          <td>(</td>
          <td class="paramtype">CODECACHE_ENTEREXIT_CALLBACK&#160;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds a function that gets called whenever control enters the code cache.</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gab125523cb430986a71858e0768753565"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_AddCodeCacheExitedFunction" ref="gab125523cb430986a71858e0768753565" args="(CODECACHE_ENTEREXIT_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::CODECACHE_AddCodeCacheExitedFunction </td>
          <td>(</td>
          <td class="paramtype">CODECACHE_ENTEREXIT_CALLBACK&#160;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds a function that gets called whenever control exits the code cache.</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga16a21596da23ddd7e8463027f66a0134"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_AddFullCacheFunction" ref="ga16a21596da23ddd7e8463027f66a0134" args="(CODECACHE_FULL_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::CODECACHE_AddFullCacheFunction </td>
          <td>(</td>
          <td class="paramtype">CODECACHE_FULL_CALLBACK&#160;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds a function that gets called whenever the cache fills up.</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gad57a8a7b92874d148f837c4b13b0a641"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_AddTraceInsertedFunction" ref="gad57a8a7b92874d148f837c4b13b0a641" args="(TRACE_INSTRUMENT_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::CODECACHE_AddTraceInsertedFunction </td>
          <td>(</td>
          <td class="paramtype">TRACE_INSTRUMENT_CALLBACK&#160;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds a function that gets called whenever a trace is placed in the code cache.</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga6e213a8bb18a2a0704eab23472a07842"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_AddTraceInvalidatedFunction" ref="ga6e213a8bb18a2a0704eab23472a07842" args="(CODECACHE_TRACEINVALIDATED_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::CODECACHE_AddTraceInvalidatedFunction </td>
          <td>(</td>
          <td class="paramtype">CODECACHE_TRACEINVALIDATED_CALLBACK&#160;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds a function that gets called whenever a trace is invalidated in the code cache. (This means the trace will never be executed again, but the space is not reclaimed until a full code cache flush.</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gac5310fb42f264cc4c2b874d7b6e3f1de"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_AddTraceLinkedFunction" ref="gac5310fb42f264cc4c2b874d7b6e3f1de" args="(CODECACHE_LINKED_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::CODECACHE_AddTraceLinkedFunction </td>
          <td>(</td>
          <td class="paramtype">CODECACHE_LINKED_CALLBACK&#160;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds a function that gets called whenever a trace is linked (backpatched)</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gab4b491a7925e0e1f172b19138c51a395"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_AddTraceUnlinkedFunction" ref="gab4b491a7925e0e1f172b19138c51a395" args="(CODECACHE_UNLINKED_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::CODECACHE_AddTraceUnlinkedFunction </td>
          <td>(</td>
          <td class="paramtype">CODECACHE_UNLINKED_CALLBACK&#160;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds a function that gets called whenever a trace is unlinked (unpatched)</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gaaf55a4da7c062b4fedb4544d5ef95981"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_BlockSize" ref="gaaf55a4da7c062b4fedb4544d5ef95981" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_BlockSize </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Default size (in bytes) of code cache allocation units (code cache blocks)</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gaa12252f735d860ac0288435c0db72a9b"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_CacheSizeLimit" ref="gaa12252f735d860ac0288435c0db72a9b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_CacheSizeLimit </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Current limit imposed on the memory allowed for storing traces and exit stubs</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga0ef157780b28486a4757270c00b66108"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_ChangeBlockSize" ref="ga0ef157780b28486a4757270c00b66108" args="(USIZE block_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::CODECACHE_ChangeBlockSize </td>
          <td>(</td>
          <td class="paramtype">USIZE&#160;</td>
          <td class="paramname"> <em>block_size</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">block_size</td><td>New default size for all future code cache blocks (regions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True on successful change of default cache block size</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga4a69b3c0ecdbc972c3d79f98491f21d8"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_ChangeCacheLimit" ref="ga4a69b3c0ecdbc972c3d79f98491f21d8" args="(USIZE cache_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::CODECACHE_ChangeCacheLimit </td>
          <td>(</td>
          <td class="paramtype">USIZE&#160;</td>
          <td class="paramname"> <em>cache_size</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cache_size</td><td>New code cache size limit </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True on successful change of max code cache size</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gae2e1311e142234e705d6f6367b435428"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_ChangeMaxBblsPerTrace" ref="gae2e1311e142234e705d6f6367b435428" args="(UINT32 max_basic_blocks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::CODECACHE_ChangeMaxBblsPerTrace </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"> <em>max_basic_blocks</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">max_basic_blocks</td><td>The new limit of BBs per trace </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True on successful change of basic block limit per trace</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gaa057bcb372b7aae955e163e08e38bf82"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_ChangeMaxInsPerTrace" ref="gaa057bcb372b7aae955e163e08e38bf82" args="(UINT32 max_ins)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::CODECACHE_ChangeMaxInsPerTrace </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"> <em>max_ins</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">max_ins</td><td>The new limit of instructions per trace </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True on successful change of instruction limit per trace</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga54123ca5c5d213041e46c3c47d1030a1"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_CodeMemReserved" ref="ga54123ca5c5d213041e46c3c47d1030a1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_CodeMemReserved </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Memory size (bytes) reserved for code caching (traces and exit stubs)</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga03d298cac03ab619c7d9575ca1bc4408"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_CodeMemUsed" ref="ga03d298cac03ab619c7d9575ca1bc4408" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_CodeMemUsed </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Bytes of code cache currently occupied by traces and exit stubs</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gae89e0062f0129394fafae468a6bf8350"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_CreateNewCacheBlock" ref="gae89e0062f0129394fafae468a6bf8350" args="(USIZE block_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::CODECACHE_CreateNewCacheBlock </td>
          <td>(</td>
          <td class="paramtype">USIZE&#160;</td>
          <td class="paramname"> <em>block_size</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">block_size</td><td>The size (in bytes) of the new code cache block (region) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True on successful generation of a new code cache block</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga285de63369aba24328ddaecd8511e1df"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_DirectoryMemUsed" ref="ga285de63369aba24328ddaecd8511e1df" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_DirectoryMemUsed </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Memory size (bytes) of the code cache directory data structures Note that this is a lower bound, as it is difficult to get an accurate account for the size of all of the data structures.</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gae8971f6762d05f83a017263d024db3c5"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_ExitStubBytes" ref="gae8971f6762d05f83a017263d024db3c5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_ExitStubBytes </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Bytes of code cache currently occupied exit stubs</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga3773a88d72d3ceec4c35757e4beb2160"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_FlushCache" ref="ga3773a88d72d3ceec4c35757e4beb2160" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::CODECACHE_FlushCache </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine flushes the entire cache. We do not need to remove any links, as they will be flushed with the cache. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Boolean success if the given cache was successfully flushed</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gab979188050e346d3c01a7de307e9cbe7"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_InvalidateRange" ref="gab979188050e346d3c01a7de307e9cbe7" args="(ADDRINT start, ADDRINT end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_InvalidateRange </td>
          <td>(</td>
          <td class="paramtype">ADDRINT&#160;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ADDRINT&#160;</td>
          <td class="paramname"> <em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine unlinks and invalidates any traces in the code cache that correspond to any code in the given source program address range [start,end] </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The original program starting address of the range we want to invalidate </td></tr>
    <tr><td class="paramname">end</td><td>The original program ending address (inclusive) of the range we want to invalidate </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of Traces Invalidated</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gaf39fec242a10c873fb397f5e3d523ed1"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_InvalidateTraceAtProgramAddress" ref="gaf39fec242a10c873fb397f5e3d523ed1" args="(ADDRINT app_pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_InvalidateTraceAtProgramAddress </td>
          <td>(</td>
          <td class="paramtype">ADDRINT&#160;</td>
          <td class="paramname"> <em>app_pc</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invalidates any traces starting at the given program address. Note: More than one trace may correspond to a single program address due to register allocation </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">app_pc</td><td>The original program address (must be a trace head) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of traces sucessfully invalidated</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga7c8f5165231ddc04eeb2694c58015855"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_LinkBytes" ref="ga7c8f5165231ddc04eeb2694c58015855" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_LinkBytes </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Bytes of cache directory currently occupied by links</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga946dc189f085d5f742be7b0a66db9d2d"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_NumExitStubsInCache" ref="ga946dc189f085d5f742be7b0a66db9d2d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_NumExitStubsInCache </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of exit stubs in the entire code cache</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gabb8af5ba8a4b6f1346ed468811339e4c"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_NumTracesInCache" ref="gabb8af5ba8a4b6f1346ed468811339e4c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_NumTracesInCache </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of traces in the entire code cache</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gabe51bc22d2bd5ced0bc5526cde76f8d9"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_OriginalAddress" ref="gabe51bc22d2bd5ced0bc5526cde76f8d9" args="(ADDRINT cache_pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ADDRINT LEVEL_PINCLIENT::CODECACHE_OriginalAddress </td>
          <td>(</td>
          <td class="paramtype">ADDRINT&#160;</td>
          <td class="paramname"> <em>cache_pc</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine returns the original application address associated with the given code cache address. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cache_pc</td><td>The address of the trace in the code cache (any address, not just start of trace) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The original application address if it exists; zero is returned if no application address corresponds with the given code cache address.</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga2442ec5df29c4264fc2b0189ce1e0c2a"></a><!-- doxytag: member="LEVEL_PINCLIENT::INS_CodeCacheAddress" ref="ga2442ec5df29c4264fc2b0189ce1e0c2a" args="(INS ins)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ADDRINT LEVEL_PINCLIENT::INS_CodeCacheAddress </td>
          <td>(</td>
          <td class="paramtype">INS&#160;</td>
          <td class="paramname"> <em>ins</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine determines the code cache address of any given instruction (Note: Only valid after code cache space has been allocated for this trace - normally after the instrumentation phase.) </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Code Cache Address</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga6da59177d8a31602356372817ac1c8e2"></a><!-- doxytag: member="LEVEL_PINCLIENT::INS_CodeCacheSize" ref="ga6da59177d8a31602356372817ac1c8e2" args="(INS ins)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USIZE LEVEL_PINCLIENT::INS_CodeCacheSize </td>
          <td>(</td>
          <td class="paramtype">INS&#160;</td>
          <td class="paramname"> <em>ins</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine determines the code cache footprint of an instruction (Note: Only valid after code cache space has been allocated for this trace - normally after the instrumentation phase.) </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Size of the instrution in the code cache</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga85ee054bf89f654d960556d145c600f6"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_MemoryAllocatedForPin" ref="ga85ee054bf89f654d960556d145c600f6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USIZE LEVEL_PINCLIENT::PIN_MemoryAllocatedForPin </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine returns the amount (in bytes) of memory currently allocated by Pin for all internal structures and data. This is an accurate representation tracked through mmap calls. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Bytes of allocated memory</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga3649ba022457e9fec1b4b894f161933c"></a><!-- doxytag: member="LEVEL_PINCLIENT::TRACE_CodeCacheAddress" ref="ga3649ba022457e9fec1b4b894f161933c" args="(TRACE trace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ADDRINT LEVEL_PINCLIENT::TRACE_CodeCacheAddress </td>
          <td>(</td>
          <td class="paramtype">TRACE&#160;</td>
          <td class="paramname"> <em>trace</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine determines the starting code cache address of a trace (Note: Only valid after code cache space has been allocated for this trace - normally after the instrumentation phase.) </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Code Cache Address </dd></dl>

</div>
</div>
<a class="anchor" id="ga16a68b7cb85cdb2a707bf1adb9f4714c"></a><!-- doxytag: member="LEVEL_PINCLIENT::TRACE_CodeCacheSize" ref="ga16a68b7cb85cdb2a707bf1adb9f4714c" args="(TRACE trace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USIZE LEVEL_PINCLIENT::TRACE_CodeCacheSize </td>
          <td>(</td>
          <td class="paramtype">TRACE&#160;</td>
          <td class="paramname"> <em>trace</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine determines the code cache footprint of a trace. If instrumentation is inlined into the trace, the footprint will include that space. (Note: Only valid after code cache space has been allocated for this trace - normally after the instrumentation phase.) </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Size of the trace in the code cache</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sun Sep 30 2012 02:21:50 for Pin by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
