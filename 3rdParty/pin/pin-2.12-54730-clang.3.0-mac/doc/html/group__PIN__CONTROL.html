<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Pin: Controlling and Initializing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Controlling and Initializing</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__PIN__CONTROL.html#ga8c5c16fb133375efa3a27d3a3900c603">EXCEPT_HANDLING_RESULT</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga64b49da7310c130bcebb21c1fcaaf318">LEVEL_PINCLIENT::INTERNAL_EXCEPTION_CALLBACK</a> )(<a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid, <a class="el" href="group__EXCEPTION__API.html#ga95d87b1df51db38b0c1ed311a1fff5a5">EXCEPTION_INFO</a> *pExceptInfo, <a class="el" href="group__PHYSICAL__CONTEXT__API.html#ga3c6833a027db42b5d528a0c65cefbc07">PHYSICAL_CONTEXT</a> *pPhysCtxt, VOID *v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VOID(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga03cd6bf5e72db42913aee13f08d7591a">LEVEL_PINCLIENT::REMOVE_INSTRUMENTATION_CALLBACK</a> )(VOID *v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VOID(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gad1e358c0ce1a5aef73f263b2800deb36">LEVEL_PINCLIENT::DETACH_CALLBACK</a> )(VOID *v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VOID(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga1edd9181ea2f698c21c743be7f93267e">LEVEL_PINCLIENT::DETACH_PROBED_CALLBACK</a> )(VOID *v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VOID(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga250c31d0d85cd9ec799f30752c476841">LEVEL_PINCLIENT::ATTACH_PROBED_CALLBACK</a> )(VOID *v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VOID(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gae1c672af1a7b69eed84982ed7e3efcdb">LEVEL_PINCLIENT::APPLICATION_START_CALLBACK</a> )(VOID *v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VOID(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gaacb361fd2832e34cc92e7f03bd1f1621">LEVEL_PINCLIENT::FINI_CALLBACK</a> )(INT32 code, VOID *v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga308874ca87663350daa5608de534a0ce">LEVEL_PINCLIENT::FETCH_CALLBACK</a> )(void *buf, ADDRINT addr, size_t size, <a class="el" href="group__EXCEPTION__API.html#ga95d87b1df51db38b0c1ed311a1fff5a5">EXCEPTION_INFO</a> *pExceptInfo, VOID *v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VOID(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gabbf7a42619fda89affa3df8bddebc32e">LEVEL_PINCLIENT::OUT_OF_MEMORY_CALLBACK</a> )(size_t size, VOID *v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ADDRINT(PIN_FAST_ANALYSIS_CALL *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga1a1c5b833df7e988522aa312890d1ca4">LEVEL_PINCLIENT::MEMORY_ADDR_TRANS_CALLBACK</a> )(<a class="el" href="structPIN__MEM__TRANS__INFO.html">PIN_MEM_TRANS_INFO</a> *memTransInfo, VOID *v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VOID(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gadc08958640205e2e9ff994fdac917a25">LEVEL_PINCLIENT::FORK_CALLBACK</a> )(<a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> threadid, const <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, VOID *v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VOID(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga4b987e362ca821776c61f27af5d54574">LEVEL_PINCLIENT::THREAD_START_CALLBACK</a> )(<a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> threadIndex, <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, INT32 flags, VOID *v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VOID(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga670ae83f83ef39ac19d793e16b23c5ca">LEVEL_PINCLIENT::THREAD_FINI_CALLBACK</a> )(<a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> threadIndex, const <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, INT32 code, VOID *v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VOID(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gaf57e5726e099445f81e9b529336ba073">LEVEL_PINCLIENT::CONTEXT_CHANGE_CALLBACK</a> )(<a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> threadIndex, <a class="el" href="group__PIN__CONTROL.html#ga8e4e6511a0e09fdc5ec7d6dbf395b3a8">CONTEXT_CHANGE_REASON</a> reason, const <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *from, <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *to, INT32 info, VOID *v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef BOOL(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga93cea72a6023405d0e90c65c81a62d6f">LEVEL_PINCLIENT::INTERCEPT_SIGNAL_CALLBACK</a> )(<a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid, INT32 sig, <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, BOOL hasHandler, const <a class="el" href="group__EXCEPTION__API.html#ga95d87b1df51db38b0c1ed311a1fff5a5">EXCEPTION_INFO</a> *pExceptInfo, VOID *v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VOID(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga880c51b16479dde27cb248f038b4ab76">LEVEL_PINCLIENT::PROBES_INSERTED_CALLBACK</a> )(IMG img, VOID *v)</td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga139152abe353fdff0216a5519d261c73">LEVEL_PINCLIENT::SYMBOL_INFO_MODE</a> { <br/>
&#160;&#160;<a class="el" href="group__PIN__CONTROL.html#gga139152abe353fdff0216a5519d261c73af44e4b240fa01ca6ed3a64acf6022ce4">LEVEL_PINCLIENT::NO_SYMBOLS</a> =  0, 
<br/>
&#160;&#160;<a class="el" href="group__PIN__CONTROL.html#gga139152abe353fdff0216a5519d261c73a3486158cb738b76b7385310ec8f5b671">LEVEL_PINCLIENT::EXPORT_SYMBOLS</a> =  (1&lt;&lt;0), 
<br/>
&#160;&#160;<a class="el" href="group__PIN__CONTROL.html#gga139152abe353fdff0216a5519d261c73a25bfc332ecb53ef24ee4ff743d09bde1">LEVEL_PINCLIENT::DEBUG_SYMBOLS</a> =  (1&lt;&lt;1), 
<br/>
&#160;&#160;<a class="el" href="group__PIN__CONTROL.html#gga139152abe353fdff0216a5519d261c73aa07edbcaef24a5dbbe880f20916bd74e">LEVEL_PINCLIENT::IFUNC_SYMBOLS</a> =  (1&lt;&lt;2), 
<br/>
&#160;&#160;<a class="el" href="group__PIN__CONTROL.html#gga139152abe353fdff0216a5519d261c73a172580d6ba02ac51ce4d3140bdafec07">LEVEL_PINCLIENT::DEBUG_OR_EXPORT_SYMBOLS</a> =  (DEBUG_SYMBOLS | EXPORT_SYMBOLS)
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gab459bf0034704bf1aa7fa7e192b7dc08">LEVEL_PINCLIENT::FPOINT</a> { <br/>
&#160;&#160;<a class="el" href="group__PIN__CONTROL.html#ggab459bf0034704bf1aa7fa7e192b7dc08ad25e85d29c19e7e0c5a9a768191bbcd7">LEVEL_PINCLIENT::FPOINT_BEFORE</a>, 
<br/>
&#160;&#160;<a class="el" href="group__PIN__CONTROL.html#ggab459bf0034704bf1aa7fa7e192b7dc08ae95eedd3db4447dda41b3fe76c7013c6">LEVEL_PINCLIENT::FPOINT_AFTER_IN_PARENT</a>, 
<br/>
&#160;&#160;<a class="el" href="group__PIN__CONTROL.html#ggab459bf0034704bf1aa7fa7e192b7dc08ab97d0822ccc4bd553feab25fc85412fc">LEVEL_PINCLIENT::FPOINT_AFTER_IN_CHILD</a>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga8e4e6511a0e09fdc5ec7d6dbf395b3a8">CONTEXT_CHANGE_REASON</a> { <br/>
&#160;&#160;<a class="el" href="group__PIN__CONTROL.html#gga8e4e6511a0e09fdc5ec7d6dbf395b3a8ae712c798df1d0e94022f6382a4c8239e">CONTEXT_CHANGE_REASON_FATALSIGNAL</a>, 
<br/>
&#160;&#160;<a class="el" href="group__PIN__CONTROL.html#gga8e4e6511a0e09fdc5ec7d6dbf395b3a8a43b8b032e969e0e5d14a3ed7385f29db">CONTEXT_CHANGE_REASON_SIGNAL</a>, 
<br/>
&#160;&#160;<a class="el" href="group__PIN__CONTROL.html#gga8e4e6511a0e09fdc5ec7d6dbf395b3a8a7e8b6943c9aa3a85b0a9cd23bc738dd9">CONTEXT_CHANGE_REASON_SIGRETURN</a>, 
<br/>
&#160;&#160;<a class="el" href="group__PIN__CONTROL.html#gga8e4e6511a0e09fdc5ec7d6dbf395b3a8a641c250ce491d66cc19f1205160dc279">CONTEXT_CHANGE_REASON_APC</a>, 
<br/>
&#160;&#160;<a class="el" href="group__PIN__CONTROL.html#gga8e4e6511a0e09fdc5ec7d6dbf395b3a8ae4c034a98f8eba91b2f8ac5b2543492b">CONTEXT_CHANGE_REASON_EXCEPTION</a>, 
<br/>
&#160;&#160;<a class="el" href="group__PIN__CONTROL.html#gga8e4e6511a0e09fdc5ec7d6dbf395b3a8a5b48097c22e4fcfdf12650129f364b50">CONTEXT_CHANGE_REASON_CALLBACK</a>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga8c5c16fb133375efa3a27d3a3900c603">EXCEPT_HANDLING_RESULT</a> { <br/>
&#160;&#160;<a class="el" href="group__PIN__CONTROL.html#gga8c5c16fb133375efa3a27d3a3900c603a32e365f541f4ea48f730a030185558cd">EHR_HANDLED</a>, 
<br/>
&#160;&#160;<a class="el" href="group__PIN__CONTROL.html#gga8c5c16fb133375efa3a27d3a3900c603ab394692e0b4ad2fda77e7597c75c9599">EHR_UNHANDLED</a>, 
<br/>
&#160;&#160;<a class="el" href="group__PIN__CONTROL.html#gga8c5c16fb133375efa3a27d3a3900c603a1950501612b017bd8db1634f7dc8bf8f">EHR_CONTINUE_SEARCH</a>
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gafec530e48213847d3a7dae8d98966e91">LEVEL_PINCLIENT::PIN_AddFollowChildProcessFunction</a> (FOLLOW_CHILD_PROCESS_CALLBACK fun, VOID *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga054599b8818c849b71e7c9d59389acae">LEVEL_PINCLIENT::PIN_AddInternalExceptionHandler</a> (INTERNAL_EXCEPTION_CALLBACK fun, VOID *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga75d9372356e0cda2acb7f5851d328575">LEVEL_PINCLIENT::PIN_TryStart</a> (<a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid, INTERNAL_EXCEPTION_CALLBACK fun, VOID *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga4b5c7f34928a2594509ba69baf404129">LEVEL_PINCLIENT::PIN_TryEnd</a> (<a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga294137f03b1d950d0f1f95968979b490">LEVEL_PINCLIENT::PIN_IsProbeMode</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gabb4b02d78ee780c3b70e86a86ff798cd">LEVEL_PINCLIENT::PIN_IsAttaching</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga389d27155d820029712f396a2a824370">LEVEL_PINCLIENT::PIN_IsSafeForProbedInsertion</a> (ADDRINT addr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga163322863f36bbbeef986c94d319eef0">LEVEL_PINCLIENT::PIN_InsertCallProbed</a> (ADDRINT addr, AFUNPTR funptr,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gadf5abd51ee9b1d599c539a9e2784e9ef">LEVEL_PINCLIENT::PIN_LockClient</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gaa6239dd852b5236f75413209aceb7a79">LEVEL_PINCLIENT::PIN_UnlockClient</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gaf5807146670d39bc546a7f4826b52cc0">LEVEL_PINCLIENT::PIN_CallApplicationFunction</a> (const <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, <a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid, <a class="el" href="group__PROTO__API.html#gacfd9f3c8dc22310ce9b9152e8c61b17c">CALLINGSTD_TYPE</a> cstype, AFUNPTR origFunPtr,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga879e5a50ab15c9468f2918b260294454">LEVEL_PINCLIENT::PIN_AddFiniFunction</a> (FINI_CALLBACK fun, VOID *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga6d6ec15c6eeb0cb70953af6cb7b4bb9a">LEVEL_PINCLIENT::PIN_AddFiniUnlockedFunction</a> (FINI_CALLBACK fun, VOID *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga50e51f92c7ea2b6d8b271ecf71a7db65">LEVEL_PINCLIENT::PIN_AddFetchFunction</a> (FETCH_CALLBACK fun, VOID *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga897b98855a1853146f9d291687f41946">LEVEL_PINCLIENT::PIN_AddOutOfMemoryFunction</a> (OUT_OF_MEMORY_CALLBACK fun, VOID *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga6d9a4cd860d8168ce1dab07da404752e">LEVEL_PINCLIENT::PIN_AddMemoryAddressTransFunction</a> (MEMORY_ADDR_TRANS_CALLBACK fun, VOID *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MEMORY_ADDR_TRANS_CALLBACK&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga8852a4e2eb765b1356069037bdf05f83">LEVEL_PINCLIENT::PIN_GetMemoryAddressTransFunction</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga0b8427c78ba3888e1c58fba45079ddce">LEVEL_PINCLIENT::PIN_AddDetachFunction</a> (DETACH_CALLBACK fun, VOID *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga76b507327796db44b1e38442e34d4ce0">LEVEL_PINCLIENT::PIN_AddDetachFunctionProbed</a> (DETACH_PROBED_CALLBACK fun, VOID *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gac19ae229338549e4cbd30b5fd453fc5e">LEVEL_PINCLIENT::PIN_AddThreadStartFunction</a> (THREAD_START_CALLBACK fun, VOID *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gaf36ad1a65cee8371238bee42a51398e6">LEVEL_PINCLIENT::PIN_AddThreadAttachProbedFunction</a> (THREAD_ATTACH_PROBED_CALLBACK fun, VOID *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga5e8f386703a124d0566fa7b35043b4e2">LEVEL_PINCLIENT::PIN_AddThreadDetachProbedFunction</a> (THREAD_DETACH_PROBED_CALLBACK fun, VOID *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga7a66a2842fc81766f2465977e18cf206">LEVEL_PINCLIENT::PIN_AddApplicationStartFunction</a> (APPLICATION_START_CALLBACK fun, VOID *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga2649cb6513a7ea51f9ff069c321c3b46">LEVEL_PINCLIENT::PIN_AddThreadFiniFunction</a> (THREAD_FINI_CALLBACK fun, VOID *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga31e63e96b8663350d196e9680b3f2b92">LEVEL_PINCLIENT::PIN_AddContextChangeFunction</a> (CONTEXT_CHANGE_CALLBACK fun, VOID *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga240de32335a0aca3ceee37ad96b1dd12">LEVEL_PINCLIENT::PIN_InterceptSignal</a> (INT32 sig, INTERCEPT_SIGNAL_CALLBACK fun, VOID *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gac7795f34b4a267644e4d10b288c38d96">LEVEL_PINCLIENT::PIN_UnblockSignal</a> (INT32 sig, BOOL enable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga788fff9fc40c870de80412810e79cb8d">LEVEL_PINCLIENT::PIN_AddProbesInsertedFunction</a> (PROBES_INSERTED_CALLBACK fun, VOID *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga8094af96abd6713333e6d744d589d8da">LEVEL_PINCLIENT::PIN_AddForkFunction</a> (FPOINT point, FORK_CALLBACK fun, VOID *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga7f5784c3b9431086f3b5b750912ca0c2">LEVEL_PINCLIENT::PIN_RemoveInstrumentation</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gafc1635c2b2550236a66dcba25f9cc8a7">LEVEL_PINCLIENT::PIN_RemoveFiniFunctions</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga6277d16bf33ede39685a26a92fc3cbef">LEVEL_PINCLIENT::PIN_Detach</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga634584cd69b124a7edd58655010e295f">LEVEL_PINCLIENT::PIN_DetachProbed</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga6f91dc7749f378605c1af61c69e9f372">LEVEL_PINCLIENT::PIN_AttachProbed</a> (ATTACH_PROBED_CALLBACK fun, VOID *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga70c7d6c2a0d8ddad7595cae915f9a9e7">LEVEL_PINCLIENT::PIN_StartProgram</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga01a31bf221500b0ca0b97fb64cc62247">LEVEL_PINCLIENT::PIN_StartProgramProbed</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga783d3bd40c3fb2ca51b1f9af31a70c9c">LEVEL_PINCLIENT::PIN_Init</a> (INT32 argc, CHAR **argv)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CHAR *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gab047eba18942e83814934eda278de607">LEVEL_PINCLIENT::PIN_VmFullPath</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga98669d2f5629027689d60bd852ffa0eb">LEVEL_PINCLIENT::PIN_SafeCopy</a> (VOID *dst, const VOID *src, size_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga271a2d60a060ddd0c13d6599afe8c0e2">LEVEL_PINCLIENT::PIN_SafeCopyEx</a> (VOID *dst, const VOID *src, size_t size, <a class="el" href="group__EXCEPTION__API.html#ga95d87b1df51db38b0c1ed311a1fff5a5">EXCEPTION_INFO</a> *pExceptInfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gac671358905f7d4dac7d544b6048e3ee3">LEVEL_PINCLIENT::PIN_IsActionPending</a> (<a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This group of functions is used to initialize Pin, start the application, and a call backs for events like application exit. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gae1c672af1a7b69eed84982ed7e3efcdb"></a><!-- doxytag: member="LEVEL_PINCLIENT::APPLICATION_START_CALLBACK" ref="gae1c672af1a7b69eed84982ed7e3efcdb" args=")(VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(* LEVEL_PINCLIENT::APPLICATION_START_CALLBACK)(VOID *v)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call back function when pin initialization is finished.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The tool's call-back value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga250c31d0d85cd9ec799f30752c476841"></a><!-- doxytag: member="LEVEL_PINCLIENT::ATTACH_PROBED_CALLBACK" ref="ga250c31d0d85cd9ec799f30752c476841" args=")(VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(* LEVEL_PINCLIENT::ATTACH_PROBED_CALLBACK)(VOID *v)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call back function when Pin attaches to application in Probe mode</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The tool's call-back value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf57e5726e099445f81e9b529336ba073"></a><!-- doxytag: member="LEVEL_PINCLIENT::CONTEXT_CHANGE_CALLBACK" ref="gaf57e5726e099445f81e9b529336ba073" args=")(THREADID threadIndex, CONTEXT_CHANGE_REASON reason, const CONTEXT *from, CONTEXT *to, INT32 info, VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(* LEVEL_PINCLIENT::CONTEXT_CHANGE_CALLBACK)(<a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> threadIndex, <a class="el" href="group__PIN__CONTROL.html#ga8e4e6511a0e09fdc5ec7d6dbf395b3a8">CONTEXT_CHANGE_REASON</a> reason, const <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *from, <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *to, INT32 info, VOID *v)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call-back function when application changes context.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">threadIndex</td><td>The Pin thread ID of the thread that changes contexts. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reason</td><td>Cause of the context change. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>Application's register state prior to the context change (NULL if <em>reason</em> is CONTEXT_CHANGE_REASON_CALLBACK). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>Application's register state after context change (NULL if <em>reason</em> is CONTEXT_CHANGE_REASON_FATALSIGNAL). The tool may change this and affect the new register state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">info</td><td>Additional information (depends on <em>reason</em>): </p>
<ul>
<li>CONTEXT_CHANGE_REASON_FATALSIGNAL: The Unix signal number. </li>
<li>CONTEXT_CHANGE_REASON_SIGNAL: The Unix signal number. </li>
<li>CONTEXT_CHANGE_REASON_EXCEPTION: The Windows exception code. </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The tool's call-back value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad1e358c0ce1a5aef73f263b2800deb36"></a><!-- doxytag: member="LEVEL_PINCLIENT::DETACH_CALLBACK" ref="gad1e358c0ce1a5aef73f263b2800deb36" args=")(VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(* LEVEL_PINCLIENT::DETACH_CALLBACK)(VOID *v)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call back function when Pin detaches from application in JIT mode</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The tool's call-back value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1edd9181ea2f698c21c743be7f93267e"></a><!-- doxytag: member="LEVEL_PINCLIENT::DETACH_PROBED_CALLBACK" ref="ga1edd9181ea2f698c21c743be7f93267e" args=")(VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(* LEVEL_PINCLIENT::DETACH_PROBED_CALLBACK)(VOID *v)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call back function when Pin detaches from application in Probe mode</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The tool's call-back value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga308874ca87663350daa5608de534a0ce"></a><!-- doxytag: member="LEVEL_PINCLIENT::FETCH_CALLBACK" ref="ga308874ca87663350daa5608de534a0ce" args=")(void *buf, ADDRINT addr, size_t size, EXCEPTION_INFO *pExceptInfo, VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t(* LEVEL_PINCLIENT::FETCH_CALLBACK)(void *buf, ADDRINT addr, size_t size, <a class="el" href="group__EXCEPTION__API.html#ga95d87b1df51db38b0c1ed311a1fff5a5">EXCEPTION_INFO</a> *pExceptInfo, VOID *v)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call back function that Pin will use to fetch code bytes to be jitted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>A buffer which receives the fetched instruction bytes. This buffer is at least <em>size</em> bytes long. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Starting address from which instruction bytes should be fetched. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of bytes that should be fetched. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pExceptInfo</td><td>If less than <em>size</em> bytes are fetched, <em>pExceptInfo</em> receives an exception that describes why more bytes could not be fetched. If Pin needs more bytes to decode the next instruction, this exception will be delivered to the application. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The tool's call-back value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes sucessfully fetched into <em>buf</em>. This may be less than <em>size</em> (or even zero) if Pin attempts to fetch instructions from an invalid address. </dd></dl>

</div>
</div>
<a class="anchor" id="gaacb361fd2832e34cc92e7f03bd1f1621"></a><!-- doxytag: member="LEVEL_PINCLIENT::FINI_CALLBACK" ref="gaacb361fd2832e34cc92e7f03bd1f1621" args=")(INT32 code, VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(* LEVEL_PINCLIENT::FINI_CALLBACK)(INT32 code, VOID *v)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call back function when application exits. It is called after all the per thread fini functions were called (registered via PIN_AddThreadFiniFunction). This function may be called on any application thread or internal thread spawned by the tool.</p>
<p>It is prohibited to access the TLS in this callback.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">code</td><td>O/S specific termination code for the application. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The tool's call-back value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadc08958640205e2e9ff994fdac917a25"></a><!-- doxytag: member="LEVEL_PINCLIENT::FORK_CALLBACK" ref="gadc08958640205e2e9ff994fdac917a25" args=")(THREADID threadid, const CONTEXT *ctxt, VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(* LEVEL_PINCLIENT::FORK_CALLBACK)(<a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> threadid, const <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, VOID *v)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call-back function when the application forks.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">threadId</td><td>Thread index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctxt</td><td>Register state immediately before/after the fork. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The tool's call-back value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga93cea72a6023405d0e90c65c81a62d6f"></a><!-- doxytag: member="LEVEL_PINCLIENT::INTERCEPT_SIGNAL_CALLBACK" ref="ga93cea72a6023405d0e90c65c81a62d6f" args=")(THREADID tid, INT32 sig, CONTEXT *ctxt, BOOL hasHandler, const EXCEPTION_INFO *pExceptInfo, VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef BOOL(* LEVEL_PINCLIENT::INTERCEPT_SIGNAL_CALLBACK)(<a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid, INT32 sig, <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, BOOL hasHandler, const <a class="el" href="group__EXCEPTION__API.html#ga95d87b1df51db38b0c1ed311a1fff5a5">EXCEPTION_INFO</a> *pExceptInfo, VOID *v)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call back function when the tool intercepts a signal with <a class="el" href="group__PIN__CONTROL.html#ga240de32335a0aca3ceee37ad96b1dd12">PIN_InterceptSignal()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tid</td><td>The Pin thread ID of the thread that handled the signal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sig</td><td>The signal number. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctxt</td><td>The application's register state when it was interrupted by the signal. The tool may change this context if desired. If so, the application continues at the modified context. Or, if the application's signal handler is invoked, the handler is passed the modified context for its return context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hasHandler</td><td>TRUE if the application has a handler registered for this signal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pExceptInfo</td><td>If the signal represents an exception, <em>pExceptInfo</em> points to a description of the exception. If the signal is not an exception, <em>pExceptInfo</em> is NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The tool's call-back value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returning TRUE tells Pin to pass the signal on to the application. Returning FALSE tells Pin to squash the signal and execution resumes at <em>ctxt</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga64b49da7310c130bcebb21c1fcaaf318"></a><!-- doxytag: member="LEVEL_PINCLIENT::INTERNAL_EXCEPTION_CALLBACK" ref="ga64b49da7310c130bcebb21c1fcaaf318" args=")(THREADID tid, EXCEPTION_INFO *pExceptInfo, PHYSICAL_CONTEXT *pPhysCtxt, VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__PIN__CONTROL.html#ga8c5c16fb133375efa3a27d3a3900c603">EXCEPT_HANDLING_RESULT</a>(* LEVEL_PINCLIENT::INTERNAL_EXCEPTION_CALLBACK)(<a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid, <a class="el" href="group__EXCEPTION__API.html#ga95d87b1df51db38b0c1ed311a1fff5a5">EXCEPTION_INFO</a> *pExceptInfo, <a class="el" href="group__PHYSICAL__CONTEXT__API.html#ga3c6833a027db42b5d528a0c65cefbc07">PHYSICAL_CONTEXT</a> *pPhysCtxt, VOID *v)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Handler (call-back) function when pin/tool generates internal exception. This function can be registered via <a class="el" href="group__PIN__CONTROL.html#ga054599b8818c849b71e7c9d59389acae">PIN_AddInternalExceptionHandler()</a> or <a class="el" href="group__PIN__CONTROL.html#ga75d9372356e0cda2acb7f5851d328575">PIN_TryStart()</a>. This function becomes active only after APPLICATION_START_CALLBACK notification is delivered. Any internal exception prior to this event can't be handled.</p>
<p>If the exception occurred while analysis routine is executed, it is legal to modify the execution control path using functions such as <a class="el" href="group__EXCEPTION__API.html#ga656279818bb8972fbdac576b57854561">PIN_RaiseException()</a> or <a class="el" href="group__CONTEXT__API.html#gaa836395fa2c09ed62f85d74b46970659">PIN_ExecuteAt()</a>. In this case, any per-thread INTERNAL_EXCEPTION_CALLBACK function registered via <a class="el" href="group__PIN__CONTROL.html#ga75d9372356e0cda2acb7f5851d328575">PIN_TryStart()</a> will be unregistered automatically (similar semantics to <a class="el" href="group__PIN__CONTROL.html#ga4b5c7f34928a2594509ba69baf404129">PIN_TryEnd()</a> for all registered notifications)</p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is unsupported to call <a class="el" href="group__PIN__CONTROL.html#gaf5807146670d39bc546a7f4826b52cc0">PIN_CallApplicationFunction()</a> in the scope of this callback</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tid</td><td>The Pin thread ID of the thread that generated the exception. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pExceptInfo</td><td>Pointer to the EXCEPTION_INFO structure that describes the exception. If the exception should be raised in the context of the application (using <a class="el" href="group__EXCEPTION__API.html#ga656279818bb8972fbdac576b57854561">PIN_RaiseException()</a>), The tool should update the exception info to match the OS logic (e.g. update exception address using <a class="el" href="group__EXCEPTION__API.html#ga397741c75f32043c9fcf6525f668678a">PIN_SetExceptionAddress()</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pPhysCtxt</td><td>Physical register state when the exception was generated. The tool can change <em>pPhysCtxt</em> (make sure that if <a class="el" href="group__PIN__CONTROL.html#ga75d9372356e0cda2acb7f5851d328575">PIN_TryStart()</a> was called, matching <a class="el" href="group__PIN__CONTROL.html#ga4b5c7f34928a2594509ba69baf404129">PIN_TryEnd()</a> will be called) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The tool's call-back value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an <em>EXCEPT_HANDLING_RESULT</em> value </dd></dl>

</div>
</div>
<a class="anchor" id="ga1a1c5b833df7e988522aa312890d1ca4"></a><!-- doxytag: member="LEVEL_PINCLIENT::MEMORY_ADDR_TRANS_CALLBACK" ref="ga1a1c5b833df7e988522aa312890d1ca4" args=")(PIN_MEM_TRANS_INFO *memTransInfo, VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ADDRINT(PIN_FAST_ANALYSIS_CALL * LEVEL_PINCLIENT::MEMORY_ADDR_TRANS_CALLBACK)(<a class="el" href="structPIN__MEM__TRANS__INFO.html">PIN_MEM_TRANS_INFO</a> *memTransInfo, VOID *v)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call back function for pin/tool to modify memory address arguments in analysis routines. This feature allows users to register for a callback immediately prior to an analysis routine which gets one of the four IARG_MEMORY*_PTR as a parameter. The callback enables the user to manipulate the memory address pointed to by the aforementioned parameter. This function can be registered via <a class="el" href="group__PIN__CONTROL.html#ga6d9a4cd860d8168ce1dab07da404752e">PIN_AddMemoryAddressTransFunction()</a>. This function is called from the jitted code, so calls to this function are not serialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">memTransInfo</td><td>Memory address data structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The tool's call-back value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabbf7a42619fda89affa3df8bddebc32e"></a><!-- doxytag: member="LEVEL_PINCLIENT::OUT_OF_MEMORY_CALLBACK" ref="gabbf7a42619fda89affa3df8bddebc32e" args=")(size_t size, VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(* LEVEL_PINCLIENT::OUT_OF_MEMORY_CALLBACK)(size_t size, VOID *v)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call back function when pin/tool is out of memory. This function can be registered via <a class="el" href="group__PIN__CONTROL.html#ga897b98855a1853146f9d291687f41946">PIN_AddOutOfMemoryFunction()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the failed allocation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The tool's call-back value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga880c51b16479dde27cb248f038b4ab76"></a><!-- doxytag: member="LEVEL_PINCLIENT::PROBES_INSERTED_CALLBACK" ref="ga880c51b16479dde27cb248f038b4ab76" args=")(IMG img, VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(* LEVEL_PINCLIENT::PROBES_INSERTED_CALLBACK)(IMG img, VOID *v)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Callback function when probe insertion is complete.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>Image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The tool's call-back value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga03cd6bf5e72db42913aee13f08d7591a"></a><!-- doxytag: member="LEVEL_PINCLIENT::REMOVE_INSTRUMENTATION_CALLBACK" ref="ga03cd6bf5e72db42913aee13f08d7591a" args=")(VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(* LEVEL_PINCLIENT::REMOVE_INSTRUMENTATION_CALLBACK)(VOID *v)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call back function when Pin removes all old instrumented code from its cache</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The tool's call-back value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga670ae83f83ef39ac19d793e16b23c5ca"></a><!-- doxytag: member="LEVEL_PINCLIENT::THREAD_FINI_CALLBACK" ref="ga670ae83f83ef39ac19d793e16b23c5ca" args=")(THREADID threadIndex, const CONTEXT *ctxt, INT32 code, VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(* LEVEL_PINCLIENT::THREAD_FINI_CALLBACK)(<a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> threadIndex, const <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, INT32 code, VOID *v)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call-back function when thread ends.</p>
<p>This function may be called on a different thread than the given threadIndex.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">threadIndex</td><td>The Pin thread ID of the terminating thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctxt</td><td>Register state of the thread immediately before it terminates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">code</td><td>O/S specific termination code for the thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The tool's call-back value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4b987e362ca821776c61f27af5d54574"></a><!-- doxytag: member="LEVEL_PINCLIENT::THREAD_START_CALLBACK" ref="ga4b987e362ca821776c61f27af5d54574" args=")(THREADID threadIndex, CONTEXT *ctxt, INT32 flags, VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(* LEVEL_PINCLIENT::THREAD_START_CALLBACK)(<a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> threadIndex, <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, INT32 flags, VOID *v)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call-back function when thread begins.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">threadIndex</td><td>The Pin thread ID of the new thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctxt</td><td>Initial register state for the new thread. The tool may change this. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>O/S specific flags for the new thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The tool's call-back value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga8e4e6511a0e09fdc5ec7d6dbf395b3a8"></a><!-- doxytag: member="types_vmapi.H::CONTEXT_CHANGE_REASON" ref="ga8e4e6511a0e09fdc5ec7d6dbf395b3a8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__PIN__CONTROL.html#ga8e4e6511a0e09fdc5ec7d6dbf395b3a8">CONTEXT_CHANGE_REASON</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Possible reasons for an application context change. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga8e4e6511a0e09fdc5ec7d6dbf395b3a8ae712c798df1d0e94022f6382a4c8239e"></a><!-- doxytag: member="CONTEXT_CHANGE_REASON_FATALSIGNAL" ref="gga8e4e6511a0e09fdc5ec7d6dbf395b3a8ae712c798df1d0e94022f6382a4c8239e" args="" -->CONTEXT_CHANGE_REASON_FATALSIGNAL</em>&nbsp;</td><td>
<p>Receipt of fatal Unix signal. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga8e4e6511a0e09fdc5ec7d6dbf395b3a8a43b8b032e969e0e5d14a3ed7385f29db"></a><!-- doxytag: member="CONTEXT_CHANGE_REASON_SIGNAL" ref="gga8e4e6511a0e09fdc5ec7d6dbf395b3a8a43b8b032e969e0e5d14a3ed7385f29db" args="" -->CONTEXT_CHANGE_REASON_SIGNAL</em>&nbsp;</td><td>
<p>Receipt of handled Unix signal. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga8e4e6511a0e09fdc5ec7d6dbf395b3a8a7e8b6943c9aa3a85b0a9cd23bc738dd9"></a><!-- doxytag: member="CONTEXT_CHANGE_REASON_SIGRETURN" ref="gga8e4e6511a0e09fdc5ec7d6dbf395b3a8a7e8b6943c9aa3a85b0a9cd23bc738dd9" args="" -->CONTEXT_CHANGE_REASON_SIGRETURN</em>&nbsp;</td><td>
<p>Return from Unix signal handler. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga8e4e6511a0e09fdc5ec7d6dbf395b3a8a641c250ce491d66cc19f1205160dc279"></a><!-- doxytag: member="CONTEXT_CHANGE_REASON_APC" ref="gga8e4e6511a0e09fdc5ec7d6dbf395b3a8a641c250ce491d66cc19f1205160dc279" args="" -->CONTEXT_CHANGE_REASON_APC</em>&nbsp;</td><td>
<p>Receipt of Windows APC. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga8e4e6511a0e09fdc5ec7d6dbf395b3a8ae4c034a98f8eba91b2f8ac5b2543492b"></a><!-- doxytag: member="CONTEXT_CHANGE_REASON_EXCEPTION" ref="gga8e4e6511a0e09fdc5ec7d6dbf395b3a8ae4c034a98f8eba91b2f8ac5b2543492b" args="" -->CONTEXT_CHANGE_REASON_EXCEPTION</em>&nbsp;</td><td>
<p>Receipt of Windows exception. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga8e4e6511a0e09fdc5ec7d6dbf395b3a8a5b48097c22e4fcfdf12650129f364b50"></a><!-- doxytag: member="CONTEXT_CHANGE_REASON_CALLBACK" ref="gga8e4e6511a0e09fdc5ec7d6dbf395b3a8a5b48097c22e4fcfdf12650129f364b50" args="" -->CONTEXT_CHANGE_REASON_CALLBACK</em>&nbsp;</td><td>
<p>Receipt of Windows call-back. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8c5c16fb133375efa3a27d3a3900c603"></a><!-- doxytag: member="types_vmapi.H::EXCEPT_HANDLING_RESULT" ref="ga8c5c16fb133375efa3a27d3a3900c603" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__PIN__CONTROL.html#ga8c5c16fb133375efa3a27d3a3900c603">EXCEPT_HANDLING_RESULT</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Possible return values of the INTERNAL_EXCEPTION_CALLBACK exception filter function </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga8c5c16fb133375efa3a27d3a3900c603a32e365f541f4ea48f730a030185558cd"></a><!-- doxytag: member="EHR_HANDLED" ref="gga8c5c16fb133375efa3a27d3a3900c603a32e365f541f4ea48f730a030185558cd" args="" -->EHR_HANDLED</em>&nbsp;</td><td>
<p>Exception is handled. Continue execution with the internal physical context. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga8c5c16fb133375efa3a27d3a3900c603ab394692e0b4ad2fda77e7597c75c9599"></a><!-- doxytag: member="EHR_UNHANDLED" ref="gga8c5c16fb133375efa3a27d3a3900c603ab394692e0b4ad2fda77e7597c75c9599" args="" -->EHR_UNHANDLED</em>&nbsp;</td><td>
<p>Exception is not handled. Execute default system procedure for unhandled exceptions (Windows) or abort the process (Unix) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga8c5c16fb133375efa3a27d3a3900c603a1950501612b017bd8db1634f7dc8bf8f"></a><!-- doxytag: member="EHR_CONTINUE_SEARCH" ref="gga8c5c16fb133375efa3a27d3a3900c603a1950501612b017bd8db1634f7dc8bf8f" args="" -->EHR_CONTINUE_SEARCH</em>&nbsp;</td><td>
<p>Execute next (upper level) exception filter function, if any. For the uppermost filter, this is the same as EHR_UNHANDLED semantics </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gab459bf0034704bf1aa7fa7e192b7dc08"></a><!-- doxytag: member="LEVEL_PINCLIENT::FPOINT" ref="gab459bf0034704bf1aa7fa7e192b7dc08" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__PIN__CONTROL.html#gab459bf0034704bf1aa7fa7e192b7dc08">LEVEL_PINCLIENT::FPOINT</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>time of callback notification </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggab459bf0034704bf1aa7fa7e192b7dc08ad25e85d29c19e7e0c5a9a768191bbcd7"></a><!-- doxytag: member="FPOINT_BEFORE" ref="ggab459bf0034704bf1aa7fa7e192b7dc08ad25e85d29c19e7e0c5a9a768191bbcd7" args="" -->FPOINT_BEFORE</em>&nbsp;</td><td>
<p>Call-back in parent, just before fork. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab459bf0034704bf1aa7fa7e192b7dc08ae95eedd3db4447dda41b3fe76c7013c6"></a><!-- doxytag: member="FPOINT_AFTER_IN_PARENT" ref="ggab459bf0034704bf1aa7fa7e192b7dc08ae95eedd3db4447dda41b3fe76c7013c6" args="" -->FPOINT_AFTER_IN_PARENT</em>&nbsp;</td><td>
<p>Call-back in parent, immediately after fork. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab459bf0034704bf1aa7fa7e192b7dc08ab97d0822ccc4bd553feab25fc85412fc"></a><!-- doxytag: member="FPOINT_AFTER_IN_CHILD" ref="ggab459bf0034704bf1aa7fa7e192b7dc08ab97d0822ccc4bd553feab25fc85412fc" args="" -->FPOINT_AFTER_IN_CHILD</em>&nbsp;</td><td>
<p>Call-back in child, immediately after fork. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga139152abe353fdff0216a5519d261c73"></a><!-- doxytag: member="LEVEL_PINCLIENT::SYMBOL_INFO_MODE" ref="ga139152abe353fdff0216a5519d261c73" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__PIN__CONTROL.html#ga139152abe353fdff0216a5519d261c73">LEVEL_PINCLIENT::SYMBOL_INFO_MODE</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>List of supported modes of symbolic information delivery. Used in PIN_InitSymbolsAlt(). </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga139152abe353fdff0216a5519d261c73af44e4b240fa01ca6ed3a64acf6022ce4"></a><!-- doxytag: member="NO_SYMBOLS" ref="gga139152abe353fdff0216a5519d261c73af44e4b240fa01ca6ed3a64acf6022ce4" args="" -->NO_SYMBOLS</em>&nbsp;</td><td>
<p>No symbols required. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga139152abe353fdff0216a5519d261c73a3486158cb738b76b7385310ec8f5b671"></a><!-- doxytag: member="EXPORT_SYMBOLS" ref="gga139152abe353fdff0216a5519d261c73a3486158cb738b76b7385310ec8f5b671" args="" -->EXPORT_SYMBOLS</em>&nbsp;</td><td>
<p>Only symbols taken from export table are provided (Windows only) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga139152abe353fdff0216a5519d261c73a25bfc332ecb53ef24ee4ff743d09bde1"></a><!-- doxytag: member="DEBUG_SYMBOLS" ref="gga139152abe353fdff0216a5519d261c73a25bfc332ecb53ef24ee4ff743d09bde1" args="" -->DEBUG_SYMBOLS</em>&nbsp;</td><td>
<p>Debug symbols (Windows only, currently implemented as DEBUG_OR_EXPORT_SYMBOLS) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga139152abe353fdff0216a5519d261c73aa07edbcaef24a5dbbe880f20916bd74e"></a><!-- doxytag: member="IFUNC_SYMBOLS" ref="gga139152abe353fdff0216a5519d261c73aa07edbcaef24a5dbbe880f20916bd74e" args="" -->IFUNC_SYMBOLS</em>&nbsp;</td><td>
<p>IFUNC symbols (Linux only) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga139152abe353fdff0216a5519d261c73a172580d6ba02ac51ce4d3140bdafec07"></a><!-- doxytag: member="DEBUG_OR_EXPORT_SYMBOLS" ref="gga139152abe353fdff0216a5519d261c73a172580d6ba02ac51ce4d3140bdafec07" args="" -->DEBUG_OR_EXPORT_SYMBOLS</em>&nbsp;</td><td>
<p>First debug symbols if available, otherwise export symbols (Windows only) </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga7a66a2842fc81766f2465977e18cf206"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddApplicationStartFunction" ref="ga7a66a2842fc81766f2465977e18cf206" args="(APPLICATION_START_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_AddApplicationStartFunction </td>
          <td>(</td>
          <td class="paramtype">APPLICATION_START_CALLBACK&#160;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register a notification function that is called after pin initialization is finished. This notification function is available when pin launches the application and when pin attaches to a running process.</p>
<p>When pin launches the application, this notification function is called on the application's main thread.</p>
<p>When pin attaches to a running process, this notification function is called on a dedicated thread which is not part of the application's threads.<br/>
 When it is called, all the application's threads are paused by Pin and are about to be released.<br/>
 No new threads can be created by the application at this time.</p>
<p>When Pin starts running a program, it calls into the tool several times in the following order:<br/>
 1. Calls the tool's main() function.<br/>
 2. If the tool set up a notification with <a class="el" href="group__IMG__BASIC__API.html#gade144ad2da442ec59c351475e42565b3">IMG_AddInstrumentFunction()</a>, Pin calls this call-back for each image that is already loaded in the application's address space at the point when Pin attaches to it.<br/>
 3. Calls any notification call-backs set up with <a class="el" href="group__PIN__CONTROL.html#ga7a66a2842fc81766f2465977e18cf206">PIN_AddApplicationStartFunction()</a>.<br/>
</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>Function to be called at application start. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to pass to the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br/>
 <b>O/S</b>: Windows, Linux<br/>
 <b>CPU:</b> IA-32, Intel(R) 64<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga31e63e96b8663350d196e9680b3f2b92"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddContextChangeFunction" ref="ga31e63e96b8663350d196e9680b3f2b92" args="(CONTEXT_CHANGE_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_AddContextChangeFunction </td>
          <td>(</td>
          <td class="paramtype">CONTEXT_CHANGE_CALLBACK&#160;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register a notification function that is called immediately before the application changes context due to receipt of an asynchronous event such as Unix signal or Windows APC.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>Call-back function to execute immediately before the application changes context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to pass to the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga0b8427c78ba3888e1c58fba45079ddce"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddDetachFunction" ref="ga0b8427c78ba3888e1c58fba45079ddce" args="(DETACH_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_AddDetachFunction </td>
          <td>(</td>
          <td class="paramtype">DETACH_CALLBACK&#160;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call func immediately before Pin relinquishes control of the application through <a class="el" href="group__PIN__CONTROL.html#ga6277d16bf33ede39685a26a92fc3cbef">PIN_Detach()</a>.</p>
<p>At this stage no more instrumentation/analysis callbacks will be called</p>
<p>This function is called one time for the process. It may be called by any thread. Pin memory is not freed at this moment.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fun</td><td>Call back function to execute before detaching </td></tr>
    <tr><td class="paramname">val</td><td>Value to be passed to fun when it is called</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga76b507327796db44b1e38442e34d4ce0"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddDetachFunctionProbed" ref="ga76b507327796db44b1e38442e34d4ce0" args="(DETACH_PROBED_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_AddDetachFunctionProbed </td>
          <td>(</td>
          <td class="paramtype">DETACH_PROBED_CALLBACK&#160;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register a notification function that is called immediately after Pin relinquishes control of the application through <a class="el" href="group__PIN__CONTROL.html#ga634584cd69b124a7edd58655010e295f">PIN_DetachProbed()</a>. There can be more than one Detach callback function.<br/>
 When this callback function is called, it is guaranteed that Pin removed all probes from the application code and that no other callback function will be called afterwards (except from additional Detach callback functions).<br/>
</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fun</td><td>Call back function to execute before detaching </td></tr>
    <tr><td class="paramname">val</td><td>Value to be passed to fun when it is called</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br/>
 <b>O/S</b>: Windows, Linux<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga50e51f92c7ea2b6d8b271ecf71a7db65"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddFetchFunction" ref="ga50e51f92c7ea2b6d8b271ecf71a7db65" args="(FETCH_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_AddFetchFunction </td>
          <td>(</td>
          <td class="paramtype">FETCH_CALLBACK&#160;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called to register a function That will become the function that Pin calls to fetch application instructions. Pin sometimes attempt to fetch instructions from an invalid address, and the call-back needs to handle this correctly. If multiple functions are registered using this API, only the last one registered is used</p>
<p>Pin cannot automatically detect self-modifying code (SMC) when a tool uses this API. Therefore, such tools take over responsibility for detecting SMC and must invalidate the code cache with <a class="el" href="group__CODECACHE__API.html#gab979188050e346d3c01a7de307e9cbe7">CODECACHE_InvalidateRange()</a> if self-modifying code is detected.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>The tool's call-back function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The tool's call-back value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga879e5a50ab15c9468f2918b260294454"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddFiniFunction" ref="ga879e5a50ab15c9468f2918b260294454" args="(FINI_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_AddFiniFunction </td>
          <td>(</td>
          <td class="paramtype">FINI_CALLBACK&#160;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call func immediately before the application exits. The function is not an instrumentation function--it cannot insert instrumentation. There can be more than one Fini function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fun</td><td>Call back function is passed exit code and val </td></tr>
    <tr><td class="paramname">val</td><td>Value to be passed to fun when it is called</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga6d6ec15c6eeb0cb70953af6cb7b4bb9a"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddFiniUnlockedFunction" ref="ga6d6ec15c6eeb0cb70953af6cb7b4bb9a" args="(FINI_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_AddFiniUnlockedFunction </td>
          <td>(</td>
          <td class="paramtype">FINI_CALLBACK&#160;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register a function to be called when the application is about to exit. The registered function will be executed in a thread that does not hold any thread synchronization lock in Pin. It means that this callback function can be executed concurrently with other Pin callbacks and APIs.<br/>
 All callbacks registered by this function will be executed before any callback registered by the <a class="el" href="group__PIN__CONTROL.html#ga879e5a50ab15c9468f2918b260294454">PIN_AddFiniFunction()</a> function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fun</td><td>Callback function to be registered </td></tr>
    <tr><td class="paramname">val</td><td>Value to be passed to fun when it is called</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gafec530e48213847d3a7dae8d98966e91"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddFollowChildProcessFunction" ref="gafec530e48213847d3a7dae8d98966e91" args="(FOLLOW_CHILD_PROCESS_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_AddFollowChildProcessFunction </td>
          <td>(</td>
          <td class="paramtype">FOLLOW_CHILD_PROCESS_CALLBACK&#160;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register a notification function that is called before a child/exec-ed process is starting to execute</p>
<p>NOTE: Only one callback can be registered</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>Call-back function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to pass to the function</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br/>
 <b>O/S</b>: Windows, Linux, MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga8094af96abd6713333e6d744d589d8da"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddForkFunction" ref="ga8094af96abd6713333e6d744d589d8da" args="(FPOINT point, FORK_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_AddForkFunction </td>
          <td>(</td>
          <td class="paramtype">FPOINT&#160;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FORK_CALLBACK&#160;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register a notification handler that is called when the application forks a new process. The function can only be used on Linux.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">where</td><td>Tells when to make the call-back and tells whether the parent or child makes the call-back. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>Call-back function to execute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Value passed as final parameter to call-back.</td></tr>
  </table>
  </dd>
</dl>
<p>If the fork function fails, the FPOINT_AFTER_IN_PARENT function, if it exists, is still called.</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga054599b8818c849b71e7c9d59389acae"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddInternalExceptionHandler" ref="ga054599b8818c849b71e7c9d59389acae" args="(INTERNAL_EXCEPTION_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_AddInternalExceptionHandler </td>
          <td>(</td>
          <td class="paramtype">INTERNAL_EXCEPTION_CALLBACK&#160;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register a global (not per-thread) notification handler function that is called upon receipt of any unhandled internal exception in Pin or the tool. This handler does not catch exceptions that are generated by the application, nor does it catch exceptions that are handled by <a class="el" href="group__PIN__CONTROL.html#ga75d9372356e0cda2acb7f5851d328575">PIN_TryStart()</a> / <a class="el" href="group__PIN__CONTROL.html#ga4b5c7f34928a2594509ba69baf404129">PIN_TryEnd()</a>. The handler is active for all the application's threads, it should be called in tool's main() before <a class="el" href="group__PIN__CONTROL.html#ga70c7d6c2a0d8ddad7595cae915f9a9e7">PIN_StartProgram()</a>. If it is called after <a class="el" href="group__PIN__CONTROL.html#ga70c7d6c2a0d8ddad7595cae915f9a9e7">PIN_StartProgram()</a> is called, it will be ignored. The user can register up to MAX_IEH_CALLBACKS global notification functions.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function should be used for permanent global call-back registration (as opposed to <a class="el" href="group__PIN__CONTROL.html#ga75d9372356e0cda2acb7f5851d328575">PIN_TryStart()</a> / <a class="el" href="group__PIN__CONTROL.html#ga4b5c7f34928a2594509ba69baf404129">PIN_TryEnd()</a> pair which should be used for function scope registration).</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>Handler function to execute upon receipt of internal exception in pin/tool. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to pass to the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Windows<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga6d9a4cd860d8168ce1dab07da404752e"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddMemoryAddressTransFunction" ref="ga6d9a4cd860d8168ce1dab07da404752e" args="(MEMORY_ADDR_TRANS_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_AddMemoryAddressTransFunction </td>
          <td>(</td>
          <td class="paramtype">MEMORY_ADDR_TRANS_CALLBACK&#160;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register a callback for modifying memory address arguments that are passed to analysis routines. See MEMORY_ADDR_TRANS_CALLBACK for usage details. <br/>
</p>
<p>Only one such callback may be registered. <br/>
</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fun</td><td>Call back function is passed the thread id, address, size, read </td></tr>
    <tr><td class="paramname">val</td><td>Value to be passed to fun when it is called </td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT <br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga897b98855a1853146f9d291687f41946"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddOutOfMemoryFunction" ref="ga897b98855a1853146f9d291687f41946" args="(OUT_OF_MEMORY_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_AddOutOfMemoryFunction </td>
          <td>(</td>
          <td class="paramtype">OUT_OF_MEMORY_CALLBACK&#160;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register a notification function that is called when pin/tool is out of memory.<br/>
 Try to reduce memory consumption when this notification function is called.<br/>
 Any implicit or explicit usage of malloc()/realloc() etc. in this notification function might cause an infinite recursion.<br/>
 The call to the notification function is NOT serialized by pin. The user can't assume anything about the locks state while the notification is delivered (as out of memory condition can occur anywhere). Avoid dead-locks by careful design of the notification function.<br/>
</p>
<p>A tool can register only one notification function.<br/>
 A new notification function registration overwrites any previous registration.<br/>
 To disable the notification function, pass a NULL function pointer.<br/>
</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fun</td><td>Call back function is passed the size of the failing allocation </td></tr>
    <tr><td class="paramname">val</td><td>Value to be passed to fun when it is called </td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; PROBE<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga788fff9fc40c870de80412810e79cb8d"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddProbesInsertedFunction" ref="ga788fff9fc40c870de80412810e79cb8d" args="(PROBES_INSERTED_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_AddProbesInsertedFunction </td>
          <td>(</td>
          <td class="paramtype">PROBES_INSERTED_CALLBACK&#160;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register a notification function that is called when Pin has inserted all probes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>Image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>Callback function to execute when probe insertion is complete. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to pass to the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br/>
 <b>O/S</b>: Linux, Windows<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gaf36ad1a65cee8371238bee42a51398e6"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddThreadAttachProbedFunction" ref="gaf36ad1a65cee8371238bee42a51398e6" args="(THREAD_ATTACH_PROBED_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_AddThreadAttachProbedFunction </td>
          <td>(</td>
          <td class="paramtype">THREAD_ATTACH_PROBED_CALLBACK&#160;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API is useful when Pin is run in probe mode and attaches to a running process. Tools may use this API to register a notification that is called by each application thread.</p>
<p>After Pin attaches to the process, Pin first notifies the tool of any images that are loaded (see <a class="el" href="group__IMG__BASIC__API.html#gade144ad2da442ec59c351475e42565b3">IMG_AddInstrumentFunction()</a>) and then notifies the tool that initialization is complete (see <a class="el" href="group__PIN__CONTROL.html#ga7a66a2842fc81766f2465977e18cf206">PIN_AddApplicationStartFunction()</a>). After that, each thread in the application calls the notification set up by <a class="el" href="group__PIN__CONTROL.html#gaf36ad1a65cee8371238bee42a51398e6">PIN_AddThreadAttachProbedFunction()</a>. After each thread returns from this notification, it resumes execution in the application code.</p>
<p>Note, this notification happens only for threads that exist in the process at the time that Pin attaches. It does not happen for threads that are created in the process after Pin is already attached.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>Call-back function to execute for the attached thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to pass to the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br/>
 <b>O/S</b>: Linux<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga5e8f386703a124d0566fa7b35043b4e2"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddThreadDetachProbedFunction" ref="ga5e8f386703a124d0566fa7b35043b4e2" args="(THREAD_DETACH_PROBED_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_AddThreadDetachProbedFunction </td>
          <td>(</td>
          <td class="paramtype">THREAD_DETACH_PROBED_CALLBACK&#160;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API is useful when Pin runs in probe mode and detaches from a running process. Tools may use this API to register a notification that is called by each application thread before any probes removal. This notification is given in the thread native context.</p>
<p>Note, this notification happens only for threads that exist in the process at the time that Pin detaches. It does not happen for threads that are created in the process after Pin is already detached.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>Call-back function to execute by the detaching thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to pass to the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br/>
 <b>O/S</b>: Linux<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga2649cb6513a7ea51f9ff069c321c3b46"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddThreadFiniFunction" ref="ga2649cb6513a7ea51f9ff069c321c3b46" args="(THREAD_FINI_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_AddThreadFiniFunction </td>
          <td>(</td>
          <td class="paramtype">THREAD_FINI_CALLBACK&#160;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register a notification function that is called when an application thread terminates. The call-back happens even for the application's root (initial) thread.</p>
<p>The notification call-back will often happen on the physical thread that is exiting, but under some circumstances it will be called on a different physical thread.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>Call-back function to execute for the terminating thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to pass to the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gac19ae229338549e4cbd30b5fd453fc5e"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddThreadStartFunction" ref="gac19ae229338549e4cbd30b5fd453fc5e" args="(THREAD_START_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_AddThreadStartFunction </td>
          <td>(</td>
          <td class="paramtype">THREAD_START_CALLBACK&#160;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register a notification function that is called when a thread starts executing in the application. The call-back happens even for the application's root (initial) thread.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>Call-back function to execute for the new thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to pass to the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga6f91dc7749f378605c1af61c69e9f372"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AttachProbed" ref="ga6f91dc7749f378605c1af61c69e9f372" args="(ATTACH_PROBED_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_AttachProbed </td>
          <td>(</td>
          <td class="paramtype">ATTACH_PROBED_CALLBACK&#160;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate Pin attach request in probe mode. If Pin was not detached (using <a class="el" href="group__PIN__CONTROL.html#ga634584cd69b124a7edd58655010e295f">PIN_DetachProbed()</a>) this function will be ignored.<br/>
 The given notification function will be called immediately after Pin regain control of the application. It is expected that in the scope of this callback, the tool will register callbacks (e.g. <a class="el" href="group__IMG__BASIC__API.html#gade144ad2da442ec59c351475e42565b3">IMG_AddInstrumentFunction()</a>) and will reconfigure itself (if needed). In order to change tool's KNOB value, use <a class="el" href="group__KNOB__BASIC.html">KNOB: Basics</a></p>
<dl class="note"><dt><b>Note:</b></dt><dd>Pin's state can't be reconfigured in the scope of the callback function (don't use <a class="el" href="group__PIN__CONTROL.html#ga783d3bd40c3fb2ca51b1f9af31a70c9c">PIN_Init()</a>, PIN_InitSymbols(), <a class="el" href="group__PIN__CONTROL.html#ga01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a> etc.)</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fun</td><td>Call back function to execute when starting to attach </td></tr>
    <tr><td class="paramname">val</td><td>Value to be passed to fun when it is called</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br/>
 <b>O/S</b>: Windows, Linux<br/>
 <b>CPU:</b> IA32, Intel64<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gaf5807146670d39bc546a7f4826b52cc0"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_CallApplicationFunction" ref="gaf5807146670d39bc546a7f4826b52cc0" args="(const CONTEXT *ctxt, THREADID tid, CALLINGSTD_TYPE cstype, AFUNPTR origFunPtr,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_CallApplicationFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *&#160;</td>
          <td class="paramname"> <em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&#160;</td>
          <td class="paramname"> <em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PROTO__API.html#gacfd9f3c8dc22310ce9b9152e8c61b17c">CALLINGSTD_TYPE</a>&#160;</td>
          <td class="paramname"> <em>cstype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&#160;</td>
          <td class="paramname"> <em>origFunPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API allows a tool to call a function inside the application. The function is executed under control of Pin's JIT compiler, and the application code is instrumented normally. Tools should not make direct calls to application functions when Pin is in JIT mode.</p>
<p><a class="el" href="group__PIN__CONTROL.html#gaf5807146670d39bc546a7f4826b52cc0">PIN_CallApplicationFunction()</a> can be called from a replacement routine or an analysis routine, but not from a call-back. Note that this API can result in recursive execution in the tool since the called application function is also instrumented.</p>
<p>One usage model for this API is to "wrap" an application function, executing analysis code before the function is called and after it returns. To do this, use <a class="el" href="group__RTN__BASIC__API.html#ga2dcaf2242c7a62151d89c01e2f04f8c0">RTN_ReplaceSignature()</a> to replace the application function, use <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da0425900c8991df5d840dd6d9f9b03295">IARG_ORIG_FUNCPTR</a> to pass the original function pointer to the replacement routine, and use <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dad3e65d643a63acb09d12b8538434ca45">IARG_CONST_CONTEXT</a> to pass the register state. You can then call back on the original function from your replacement routine with <a class="el" href="group__PIN__CONTROL.html#gaf5807146670d39bc546a7f4826b52cc0">PIN_CallApplicationFunction()</a>. Note, however, that the overhead of <a class="el" href="group__PIN__CONTROL.html#gaf5807146670d39bc546a7f4826b52cc0">PIN_CallApplicationFunction()</a> can be high, so it is more efficient to use *_InsertCall() instead if possible.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctxt</td><td>The application register state to use when calling the function. Pin changes the register state in order to pass arguments to the function, but the <em>ctxt</em> parameter isn't changed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tid</td><td>The Pin id of the current thread (see <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451daadb6e5681193cc8435b9e57d13acf5d4">IARG_THREAD_ID</a>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cstype</td><td>The calling standard used for calling this function (CALLINGSTD_DEFAULT recommended). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">origFunPtr</td><td>The entry point of the application function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>List of function argument type and size.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="group__PROTO__API.html#gacb4faa1f3649fce55756313c6259519f">PIN_PARG</a> for the recommended method of passing function arguments. <a class="el" href="group__PROTO__API.html#gaeebb4a42707b704ebf214a06a6bf4e62">PIN_PARG_END()</a> must end the argument list, even if the function has no arguments. If the application function has a return value, it must appear first in the argument list.</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT only<br/>
 <b>O/S</b>: Linux and Windows<br/>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga6277d16bf33ede39685a26a92fc3cbef"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_Detach" ref="ga6277d16bf33ede39685a26a92fc3cbef" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_Detach </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pin relinquishes control of the application and the original un-instrumented code is executed.</p>
<p>On Linux, the function may be invoked from analysis, instrumentation or callback routines. It may be executed by any thread, including threads spawned by the Pintool which are invisible to the Pin VM.</p>
<p>On Windows and Mac Os, the function must be invoked from an analysis routine. Invoking the function from instrumentation routines could cause Pin to misbehave. See Tests/detach.C for an example of its use.</p>
<p>The request for detach is considered by Pin as asynchronous. This means that Pin will perform the detach procedure at a point which it considers convenient to do so. From the user's perspective, instrumentation, analysis or callback routines might still be executed after calling <a class="el" href="group__PIN__CONTROL.html#ga6277d16bf33ede39685a26a92fc3cbef">PIN_Detach()</a>. In practice, <a class="el" href="group__PIN__CONTROL.html#ga6277d16bf33ede39685a26a92fc3cbef">PIN_Detach()</a> simply registers the request to the Pin VM and exits immediately i.e. the function does not wait for detach to complete.</p>
<p>Once Pin starts the detach procedure, it can't be blocked, and will not run forever. It is not possible to detach one thread. All threads will run natively after <a class="el" href="group__PIN__CONTROL.html#ga6277d16bf33ede39685a26a92fc3cbef">PIN_Detach()</a>. During detach, Pin doesn't free memory used for Pin objects. This memory will be used during re-attach.</p>
<p>During the detach procedure Pin runs an auxiliary process, which communicates with the running application process via debug interface. The auxiliary process is temporary and will exit immediately when the detach procedure is completed. For the user, this means that a debugger cannot be attached to the application process during detach.</p>
<p>Use <a class="el" href="group__PIN__CONTROL.html#ga0b8427c78ba3888e1c58fba45079ddce">PIN_AddDetachFunction()</a> to receive a notification just prior to detach. The callback will be received after all the threads are stopped inside the VM and no more instrumentation functions, analysis routines or callbacks will be called.<br/>
 Note: at this point, the auxiliary process mentioned above is still attached to the application process.</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows, &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga634584cd69b124a7edd58655010e295f"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_DetachProbed" ref="ga634584cd69b124a7edd58655010e295f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_DetachProbed </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate Pin detach request in probe mode. In the scope of this operation, Pin removes all probes set by Pin &amp; tool, The user can get a notification when the detach operation has been completed (via callback registration using <a class="el" href="group__PIN__CONTROL.html#ga76b507327796db44b1e38442e34d4ce0">PIN_AddDetachFunctionProbed()</a>). On Linux, the user can get additional per-thread callbacks just prior to probes removal. (via callback registration using <a class="el" href="group__PIN__CONTROL.html#ga5e8f386703a124d0566fa7b35043b4e2">PIN_AddThreadDetachProbedFunction()</a>).These callbacks will be given for each thread in its native context. If Pin has already detached (using <a class="el" href="group__PIN__CONTROL.html#ga634584cd69b124a7edd58655010e295f">PIN_DetachProbed()</a>), or if Pin has not fully started yet (the notification function registered by <a class="el" href="group__PIN__CONTROL.html#ga7a66a2842fc81766f2465977e18cf206">PIN_AddApplicationStartFunction()</a> was not yet delivered to the tool), this function will be ignored.<br/>
</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Even though Pin removes all probes, replacement functions can still be active (for example, if the replacement function is still located on the call stack of one of the threads). It is the tool responsibility to handle these scenarios.<br/>
</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br/>
 <b>O/S</b>: Windows, Linux<br/>
 <b>CPU:</b> IA32, Intel64<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga8852a4e2eb765b1356069037bdf05f83"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_GetMemoryAddressTransFunction" ref="ga8852a4e2eb765b1356069037bdf05f83" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEMORY_ADDR_TRANS_CALLBACK LEVEL_PINCLIENT::PIN_GetMemoryAddressTransFunction </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the Registered notification function that is called when tool needs to modify memory address in PIN.<br/>
</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fun</td><td>Call back function has no parameters </td></tr>
    <tr><td class="paramname">val</td><td>Value to be passed to fun when it is called </td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; PROBE<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga783d3bd40c3fb2ca51b1f9af31a70c9c"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_Init" ref="ga783d3bd40c3fb2ca51b1f9af31a70c9c" args="(INT32 argc, CHAR **argv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_Init </td>
          <td>(</td>
          <td class="paramtype">INT32&#160;</td>
          <td class="paramname"> <em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CHAR **&#160;</td>
          <td class="paramname"> <em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize Pin system. Must be called before PIN_StartProgram </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td>argc value passed to main </td></tr>
    <tr><td class="paramname">argv</td><td>argv value passed to main, encoded in UTF8 (a superset of ASCII)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if an error was detected parsing the command line</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga163322863f36bbbeef986c94d319eef0"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_InsertCallProbed" ref="ga163322863f36bbbeef986c94d319eef0" args="(ADDRINT addr, AFUNPTR funptr,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_InsertCallProbed </td>
          <td>(</td>
          <td class="paramtype">ADDRINT&#160;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&#160;</td>
          <td class="paramname"> <em>funptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert a call to an analysis routine relative to a location. In this location we expect to find a safe instruction, i.e. an instruction which is large enough to be replaced entirely with a jump instruction (i.e. 5/7 bytes long), it is not a control flow instruction, and it doesn't have memory operand.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>the application address to instrument </td></tr>
    <tr><td class="paramname">funptr</td><td>the analysis function </td></tr>
    <tr><td class="paramname">...</td><td><a class="el" href="group__INST__ARGS.html#ga089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>. The list must end with IARG_END.</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="group__PIN__CONTROL.html#ga01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a> must be used when using this API.</p>
<p>Some restrictions apply when using IARG_CONTEXT. See <a class="el" href="group__INST__ARGS.html">Instrumentation arguments</a> for more information. IARG_THREAD_ID is not supported.</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br/>
 <b>O/S</b>: All<br/>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga240de32335a0aca3ceee37ad96b1dd12"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_InterceptSignal" ref="ga240de32335a0aca3ceee37ad96b1dd12" args="(INT32 sig, INTERCEPT_SIGNAL_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_InterceptSignal </td>
          <td>(</td>
          <td class="paramtype">INT32&#160;</td>
          <td class="paramname"> <em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INTERCEPT_SIGNAL_CALLBACK&#160;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Establish an interceptor function for signals delivered to the application. Tools should never call sigaction() directly to handle signals. The interceptor function is called whenever the application receives the requested signal, regardless of whether the application has a handler for that signal. The tool's handler can then decide whether the signal should be forwarded to the application.</p>
<p>There are two intended usage models for this API, which are both advanced features. If your tool merely needs to be notified of signals that are sent to the application, use <a class="el" href="group__PIN__CONTROL.html#ga31e63e96b8663350d196e9680b3f2b92">PIN_AddContextChangeFunction()</a> instead.</p>
<p>In one usage model, a tool can take over ownership of a signal in order to use the signal as an asynchronous communication mechanism to the outside world. For example, if a tool intercepts SIGUSR1, a user of the tool could send this signal and tell the tool to do something. In this usage model, the tool may want to call <a class="el" href="group__PIN__CONTROL.html#gac7795f34b4a267644e4d10b288c38d96">PIN_UnblockSignal()</a> so that it will receive the signal even if the application attempts to block it.</p>
<p>In the second usage model, the tool may need to "squash" certain signals that the application generates. For example, a tool that forces speculative execution in the application may want to intercept and squash exceptions generated in the speculative code.</p>
<p>A tool can set only one "intercept" handler for a particular signal, so a new handler overwrites any previous handler for the same signal. To disable a handler, pass a NULL function pointer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sig</td><td>The signal number to intercept, which may not be SIGKILL or SIGSTOP. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>The tool's intercept function, or NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to pass to the intercept function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success (always FALSE on Windows).</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gac671358905f7d4dac7d544b6048e3ee3"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_IsActionPending" ref="gac671358905f7d4dac7d544b6048e3ee3" args="(THREADID tid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_IsActionPending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&#160;</td>
          <td class="paramname"> <em>tid</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is useful when an analysis routine might block for an indefinite period of time. In such cases, the analysis code can periodically call <a class="el" href="group__PIN__CONTROL.html#gac671358905f7d4dac7d544b6048e3ee3">PIN_IsActionPending()</a> to see if the thread has some pending action that needs to be handled in the Pin VM. If so, the analysis routine should return back to the VM, either by returning or by calling <a class="el" href="group__CONTEXT__API.html#gaa836395fa2c09ed62f85d74b46970659">PIN_ExecuteAt()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tid</td><td>The ID of the calling thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the thread has a pending action in the Pin VM.</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux<br/>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gabb4b02d78ee780c3b70e86a86ff798cd"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_IsAttaching" ref="gabb4b02d78ee780c3b70e86a86ff798cd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_IsAttaching </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if Pin is being attached to a running application process </dd></dl>

</div>
</div>
<a class="anchor" id="ga294137f03b1d950d0f1f95968979b490"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_IsProbeMode" ref="ga294137f03b1d950d0f1f95968979b490" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_IsProbeMode </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Return TRUE if -probe on command line or if Tool started application calling <a class="el" href="group__PIN__CONTROL.html#ga01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a>.<br/>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Tool can run in Probe mode without specifying -probe on the command line. This switch is provided as a convenience. In that case, <a class="el" href="group__PIN__CONTROL.html#ga294137f03b1d950d0f1f95968979b490">PIN_IsProbeMode()</a> will return FALSE before <a class="el" href="group__PIN__CONTROL.html#ga01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a> was called (Since the default running mode is JIT).</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga389d27155d820029712f396a2a824370"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_IsSafeForProbedInsertion" ref="ga389d27155d820029712f396a2a824370" args="(ADDRINT addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_IsSafeForProbedInsertion </td>
          <td>(</td>
          <td class="paramtype">ADDRINT&#160;</td>
          <td class="paramname"> <em>addr</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check if the given location is safe for probe insertion. This means that the location contains an instruction which is large enough to be replaced entirely with a jump instruction (i.e. 5/7 bytes long), it is not a control flow instruction, and it doesn't have memory operand.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>the application address to instrument </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE/FALSE if the location is safe</dd></dl>
<p><a class="el" href="group__PIN__CONTROL.html#ga01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a> must be used when using this API.</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br/>
 <b>O/S</b>: All<br/>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gadf5abd51ee9b1d599c539a9e2784e9ef"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_LockClient" ref="gadf5abd51ee9b1d599c539a9e2784e9ef" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_LockClient </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Some Pin API functions may only be called when the thread is holding this lock. See also PIN_UnlockClient. The client lock is recursive, so can be claimed again by a thread if it already holds it. PIN_LockClient and PIN_UnlockClient calls must be matched, since the lock implementation maintains a depth count.<br/>
 This function can be used in any thread, including internal threads spawned by the tool.</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gafc1635c2b2550236a66dcba25f9cc8a7"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_RemoveFiniFunctions" ref="gafc1635c2b2550236a66dcba25f9cc8a7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_RemoveFiniFunctions </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invalidates all the Fini callback functions registered via PIN_AddFiniFunction; Fini callbacks will no longer be called before the application exits.</p>
<p>Must be called prior to invoking PIN_Detach if the tool has previously registered Fini callbacks and libc.so is not yet loaded into memory yet for a dynamically linked binary.</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga7f5784c3b9431086f3b5b750912ca0c2"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_RemoveInstrumentation" ref="ga7f5784c3b9431086f3b5b750912ca0c2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_RemoveInstrumentation </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>All instrumentation is removed. When application code is executed the instrumentation routines will be called to reinstrument all code. Similarly, any ahead-of-time instrumentation will be reapplied if the relevant code is re-executed.</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga98669d2f5629027689d60bd852ffa0eb"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_SafeCopy" ref="ga98669d2f5629027689d60bd852ffa0eb" args="(VOID *dst, const VOID *src, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t LEVEL_PINCLIENT::PIN_SafeCopy </td>
          <td>(</td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VOID *&#160;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"> <em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy the specified number of bytes from a source memory region to a destination memory region. The function guarantees safe return to the caller even if the source or destination regions are inaccessible (entirely or partially).</p>
<p>Tools should use this function to ensure safe access to the original content of the application's memory. For example, on Windows, Pin replaces certain TEB fields when running analysis routines in the tool. If the tool accesses these fields directly, it would see the values assigned by Pin rather than the original ones. On the contrary, <a class="el" href="group__PIN__CONTROL.html#ga98669d2f5629027689d60bd852ffa0eb">PIN_SafeCopy()</a> always reads and modifies the original application's values of these fields.</p>
<p>This function can be used in any thread, including any internal thread spawned by the tool.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>destination region </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>region to copy from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>number of bytes to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of bytes successfully copied from the source to the destination region.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd><a class="el" href="group__PIN__CONTROL.html#ga98669d2f5629027689d60bd852ffa0eb">PIN_SafeCopy()</a> should not be called before the application has been started. For instance, it cannot be called in an Image load callback. Unexpected results will occur.</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga271a2d60a060ddd0c13d6599afe8c0e2"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_SafeCopyEx" ref="ga271a2d60a060ddd0c13d6599afe8c0e2" args="(VOID *dst, const VOID *src, size_t size, EXCEPTION_INFO *pExceptInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t LEVEL_PINCLIENT::PIN_SafeCopyEx </td>
          <td>(</td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VOID *&#160;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__EXCEPTION__API.html#ga95d87b1df51db38b0c1ed311a1fff5a5">EXCEPTION_INFO</a> *&#160;</td>
          <td class="paramname"> <em>pExceptInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy the specified number of bytes from a source memory region to a destination memory region. The function guarantees safe return to the caller even if the source or destination regions are inaccessible (entirely or partially).</p>
<p>In addition to the PIN_SafeCopy functionality, this function allows the tool to obtain detailed exception information in case of failure.</p>
<p>This function can be used in any thread, including any internal thread spawned by the tool.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>destination region </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>region to copy from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>number of bytes to copy </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pExceptInfo</td><td>pointer to the structure that receives the exception information in case of failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of bytes successfully copied from the source to the destination region. If the function fails to copy all bytes, it provides detailed description of the failure in the <em></em> &lt;pExceptInfo&gt; structure.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The exception address in the returned exception information always has zero value. If the tool wants to raise this exception on behalf of the application, it should use <a class="el" href="group__EXCEPTION__API.html#ga397741c75f32043c9fcf6525f668678a">PIN_SetExceptionAddress</a> function to set an appropriate exception address before passing the exception information to the PIN_RaiseException function.</dd>
<dd>
<a class="el" href="group__PIN__CONTROL.html#ga271a2d60a060ddd0c13d6599afe8c0e2">PIN_SafeCopyEx()</a> should not be called before the application has been started. For instance, it cannot be called in an Image load callback. Unexpected results will occur.</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga70c7d6c2a0d8ddad7595cae915f9a9e7"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_StartProgram" ref="ga70c7d6c2a0d8ddad7595cae915f9a9e7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_StartProgram </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Starts executing the application, when Pin is in JIT mode, which is the default. Note that <a class="el" href="group__PIN__CONTROL.html#ga783d3bd40c3fb2ca51b1f9af31a70c9c">PIN_Init()</a> must be called before <a class="el" href="group__PIN__CONTROL.html#ga70c7d6c2a0d8ddad7595cae915f9a9e7">PIN_StartProgram()</a>.</p>
<p>The <a class="el" href="group__PIN__CONTROL.html#ga70c7d6c2a0d8ddad7595cae915f9a9e7">PIN_StartProgram()</a> function never returns. It also unwinds the tool's stack, so any local (stack based) variables are lost.</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga01a31bf221500b0ca0b97fb64cc62247"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_StartProgramProbed" ref="ga01a31bf221500b0ca0b97fb64cc62247" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_StartProgramProbed </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Starts executing the application, when Pin is in Probe mode. Note that <a class="el" href="group__PIN__CONTROL.html#ga783d3bd40c3fb2ca51b1f9af31a70c9c">PIN_Init()</a> must be called before <a class="el" href="group__PIN__CONTROL.html#ga01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a>.</p>
<p>The <a class="el" href="group__PIN__CONTROL.html#ga01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a> function never returns. It also unwinds the tool's stack, so any local (stack based) variables are lost.</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga4b5c7f34928a2594509ba69baf404129"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_TryEnd" ref="ga4b5c7f34928a2594509ba69baf404129" args="(THREADID tid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_TryEnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&#160;</td>
          <td class="paramname"> <em>tid</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unregister the last registered notification function (registered via <a class="el" href="group__PIN__CONTROL.html#ga75d9372356e0cda2acb7f5851d328575">PIN_TryStart()</a>) from the context of the calling thread. This function should be called in the same function scope as the previously registered <a class="el" href="group__PIN__CONTROL.html#ga75d9372356e0cda2acb7f5851d328575">PIN_TryStart()</a>.<br/>
 This function can be used in any thread, including any internal thread spawned by the tool.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tid</td><td>Id of the calling thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Windows, Linux<br/>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga75d9372356e0cda2acb7f5851d328575"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_TryStart" ref="ga75d9372356e0cda2acb7f5851d328575" args="(THREADID tid, INTERNAL_EXCEPTION_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_TryStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&#160;</td>
          <td class="paramname"> <em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INTERNAL_EXCEPTION_CALLBACK&#160;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register a per-thread notification handler function that is called upon receipt of an internal exception in pin or the tool in the context of the calling thread. Use <a class="el" href="group__PIN__CONTROL.html#ga4b5c7f34928a2594509ba69baf404129">PIN_TryEnd()</a> in order to remove the registered handler from the context of the calling thread (do it in the same function scope). The user can register up to MAX_IEH_CALLBACKS per-thread notification functions.<br/>
 This function can be used in any thread, including any internal thread spawned by the tool.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is unsupported to call <a class="el" href="group__PIN__CONTROL.html#gaf5807146670d39bc546a7f4826b52cc0">PIN_CallApplicationFunction()</a> in the scope of <a class="el" href="group__PIN__CONTROL.html#ga75d9372356e0cda2acb7f5851d328575">PIN_TryStart()</a> / <a class="el" href="group__PIN__CONTROL.html#ga4b5c7f34928a2594509ba69baf404129">PIN_TryEnd()</a> pair.<br/>
</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tid</td><td>Id of the calling thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>Handler function to execute upon receipt of internal exception in pin/tool. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to pass to the handler function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Windows, Linux<br/>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gac7795f34b4a267644e4d10b288c38d96"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_UnblockSignal" ref="gac7795f34b4a267644e4d10b288c38d96" args="(INT32 sig, BOOL enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_UnblockSignal </td>
          <td>(</td>
          <td class="paramtype">INT32&#160;</td>
          <td class="paramname"> <em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"> <em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API is normally used in conjunction with <a class="el" href="group__PIN__CONTROL.html#ga240de32335a0aca3ceee37ad96b1dd12">PIN_InterceptSignal()</a> to prevent the application from blocking a signal that the tool intercepts. This is useful if the tool wants to ensure that the application will not prevent the tool from receiving the intercepted signal.</p>
<p>When this API is called before <a class="el" href="group__PIN__CONTROL.html#ga70c7d6c2a0d8ddad7595cae915f9a9e7">PIN_StartProgram()</a>, it affects all threads in the application. However, if it is called after <a class="el" href="group__PIN__CONTROL.html#ga70c7d6c2a0d8ddad7595cae915f9a9e7">PIN_StartProgram()</a>, it only affects the calling thread. If the application spawns a thread, the child thread inherits the signal blocking state from its parent.</p>
<p>Tools should take care when using this API because it can adversely affect the application if it also uses the signal <em>sig</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sig</td><td>The signal number, which may not be SIGKILL or SIGSTOP. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>If TRUE, the application is prevented from blocking <em>sig</em>. If FALSE, the application may block or unblock <em>sig</em> at will.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success (always FALSE on Windows).</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gaa6239dd852b5236f75413209aceb7a79"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_UnlockClient" ref="gaa6239dd852b5236f75413209aceb7a79" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_UnlockClient </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Some Pin API functions may be called only when the thread is holding this lock. See also PIN_LockClient.<br/>
 This function can be used in any thread, including any internal thread spawned by the tool.</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br/>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gab047eba18942e83814934eda278de607"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_VmFullPath" ref="gab047eba18942e83814934eda278de607" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CHAR* LEVEL_PINCLIENT::PIN_VmFullPath </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns full path of Pin binary invoked, encoded in UTF8 (superset of ASCII), this is supported for Linux (only for locales encoded in UTF8)</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux &amp; MacOS<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sun Sep 30 2012 02:21:50 for Pin by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
